[root]
- file_list.txt
  Inhalt:


- script.py
  Inhalt:
import os


def list_files(directory, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for root, dirs, files in os.walk(directory):
            if "node_modules" in root.split(os.sep):
                continue

            rel_path = os.path.relpath(root, directory)
            f.write(f"[{rel_path if rel_path != '.' else 'root'}]\n")
            for file in files:
                if file == "package-lock.json":
                    continue
                file_path = os.path.join(root, file)
                try:
                    with open(
                        file_path, "r", encoding="utf-8", errors="ignore"
                    ) as file_content:
                        content = file_content.read()
                    f.write(f"- {file}\n")
                    f.write(f"  Inhalt:\n{content}\n\n")
                except Exception as e:
                    f.write(f"- {file} (Fehler beim Lesen: {e})\n")
            f.write("\n")


if __name__ == "__main__":
    current_directory = os.getcwd()  # Aktuelles Verzeichnis
    output_file = os.path.join(current_directory, "file_list.txt")
    list_files(current_directory, output_file)
    print(f"Dateiliste wurde in {output_file} gespeichert.")


- start_app.bat
  Inhalt:
@echo off
REM Starte Backend
start cmd /k "cd backend && npm start"

REM Starte Frontend
start cmd /k "cd frontend && npm start"

REM Warte 5 Sekunden, damit die Server hochfahren
timeout /t 5

REM Öffne das Frontend
start "" "chrome" "http://localhost:3000"

REM Öffne eine weitere Browser-Instanz mit der dryve D1 IP-Adresse
start "" "chrome" "http://169.254.104.33"



[DelibJava]
- DelibJNI64.java
  Inhalt:
package DelibJava;

//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//
//
//
//  DelibJNI64.java
//  project: DELIB
//
//
//  (c) DEDITEC GmbH, 2009-2016
//  web: http://www.deditec.de/
//  mail: vertrieb@deditec.de
//
//
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************

public class DelibJNI64
{
    static 
    {
        System.loadLibrary("DelibJNI64");
    }
    
    // all Module-ID's
    public static final int USB_Interface8                  = 1;            // USB-Controller8/USB-TTL-IN8-OUT8
    public static final int USB_CAN_STICK                   = 2;            // USB-CAN-Stick
    public static final int USB_LOGI_500                    = 3;            // USB-LOGI-500/USB-LOGI-250
    public static final int USB_SER_DEBUG                   = 4;            // USB-SER-DEBUG
    public static final int RO_SER                          = 5;            // RO-SER-Serie
    public static final int USB_BITP_200                    = 6;            // USB-BITP-200
    public static final int RO_USB1                         = 7;            // RO-USB-Serie
    public static final int RO_USB                          = 7;            // RO-USB-Serie
    public static final int RO_ETH                          = 8;            // RO-ETH-Serie
    public static final int USB_MINI_STICK                  = 9;            // USB-MINI-Stick-Serie
    public static final int USB_LOGI_18                     = 10;           // USB-LOGI-100
    public static final int RO_CAN                          = 11;           // RO-CAN-Serie
    public static final int USB_SPI_MON                     = 12;           // USB_SPI_MON
    public static final int USB_WATCHDOG                    = 13;           // USB_Watchdog
    public static final int USB_OPTOIN_8                    = 14;           // USB-OPTOIN8 / USB-RELAIS-8
    public static final int USB_RELAIS_8                    = 14;           // USB-OPTOIN8 / USB-RELAIS-8
    public static final int USB_OPTOIN_8_RELAIS_8           = 15;           // USB-OPTOIN-8-RELAIS-8
    public static final int USB_OPTOIN_16_RELAIS_16         = 16;           // USB-OPTOIN-16-RELAIS-16
    public static final int USB_OPTOIN_32                   = 16;           // USB-OPTOIN-16-RELAIS-16
    public static final int USB_RELAIS_32                   = 16;           // USB-OPTOIN-16-RELAIS-16
    public static final int USB_OPTOIN_32_RELAIS_32         = 17;           // USB-OPTOIN-32-RELAIS-32
    public static final int USB_OPTOIN_64                   = 17;           // USB-OPTOIN-32-RELAIS-32
    public static final int USB_RELAIS_64                   = 17;           // USB-OPTOIN-32-RELAIS-32

    public static final int BS_USB_8                        = 15;
    public static final int BS_USB_16                       = 16;
    public static final int BS_USB_32                       = 17;

    public static final int USB_TTL_32                      = 18;           // USB-TTL-32
    public static final int USB_TTL_64                      = 18;           // USB-TTL-64
    public static final int RO_ETH_INTERN                   = 19;

    public static final int BS_SER                          = 20;
    public static final int BS_CAN                          = 21;
    public static final int BS_ETH                          = 22;

    public static final int NET_ETH                         = 23;

    public static final int RO_CAN2                         = 24;           // RO-CPU2 / 480 MBit/sec - CAN VERSION
    public static final int RO_USB2                         = 25;           // RO-CPU2 / 480 MBit/sec - USB/SER Version
    public static final int RO_ETH_LC                       = 26;           // RO-ETH-LC

    public static final int ETH_RELAIS_8                    = 27;
    public static final int ETH_OPTOIN_8                    = 27;
    public static final int ETH_O4_R4_ADDA                  = 28;

    public static final int ETHERNET_MODULE                 = 29;

    public static final int ETH_TTL_64                      = 30;

    public static final int NET_USB2                        = 31;
    public static final int NET_ETH_LC                      = 32;
    public static final int NET_USB1                        = 33;
    public static final int NET_SER                         = 34;
    
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Declarations
    
    // ----------------------------------------------------------------------------
    // Special Function-Codes
    public static final int DAPI_SPECIAL_CMD_GET_MODULE_CONFIG                          = 1;
    public static final int DAPI_SPECIAL_CMD_TIMEOUT                                    = 2;
    public static final int DAPI_SPECIAL_CMD_DI                                         = 10;
    public static final int DAPI_SPECIAL_CMD_SET_DIR_DX_1                               = 3;
    public static final int DAPI_SPECIAL_CMD_SET_DIR_DX_8                               = 4;
    public static final int DAPI_SPECIAL_CMD_GET_MODULE_VERSION                         = 5;
    public static final int DAPI_SPECIAL_CMD_DA                                         = 6;
    public static final int DAPI_SPECIAL_CMD_WATCHDOG                                   = 7;
    public static final int DAPI_SPECIAL_CMD_COUNTER                                    = 8;
    public static final int DAPI_SPECIAL_CMD_AD                                         = 9;
    public static final int DAPI_SPECIAL_CMD_CNT48                                      = 11;
    public static final int DAPI_SPECIAL_CMD_SOFTWARE_FIFO                              = 12;
    public static final int DAPI_SPECIAL_CMD_MODULE_REBOOT                              = 13;
    public static final int DAPI_SPECIAL_CMD_MODULE_RESCAN                              = 14;
    public static final int DAPI_SPECIAL_CMD_RESTART_CHECK_MODULE_CONFIG                = 15;
    public static final int DAPI_SPECIAL_CMD_PWM                                        = 19;

    // values for PAR1
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI                       = 1;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF                    = 7;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER               = 8;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO                       = 2;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX                       = 3;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD                       = 4;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA                       = 5;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP                     = 9;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER                  = 6;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48                    = 10;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN                = 11;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT                  = 12;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_INTERFACE1            = 13;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_FEATURE1              = 14;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_GROUP                 = 15;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_CLASS                 = 16;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_MODULE_ID                = 17;
    //
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0                       = 0;
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1                       = 1;
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2                       = 2;
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3                       = 3;
    //
    public static final int DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC                          = 1;
    public static final int DAPI_SPECIAL_TIMEOUT_ACTIVATE                               = 2;
    public static final int DAPI_SPECIAL_TIMEOUT_DEACTIVATE                             = 3;
    public static final int DAPI_SPECIAL_TIMEOUT_GET_STATUS                             = 4;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_LOAD_DEFAULT					= 5;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_CLR32					= 6;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_CLR32					= 7;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_SET32					= 8;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_SET32					= 9;
    //
    public static final int DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET                         = 1;
    public static final int DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET                         = 2;
    //
    public static final int DAPI_SPECIAL_AD_READ_MULTIPLE_AD                            = 1;
    public static final int DAPI_SPECIAL_AD_FIFO_ACTIVATE                               = 2;
    public static final int DAPI_SPECIAL_AD_FIFO_DEACTIVATE                             = 3;
    public static final int DAPI_SPECIAL_AD_FIFO_GET_STATUS                             = 4;
    public static final int DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS                        = 5;
    public static final int DAPI_SPECIAL_AD_FIFO_SET_CHANNEL                            = 6;
    public static final int DAPI_SPECIAL_AD_FIFO_INIT                                   = 7;
    public static final int DAPI_SPECIAL_AD_FILTER_SET                                  = 8;
    //
    public static final int DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT                         = 1;
    public static final int DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG                   = 2;
    public static final int DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG                   = 3;
    //
    public static final int DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC                      = 1;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC                      = 2;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_STATUS                            = 3;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC                   = 4;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC       = 5;
    public static final int DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC         = 6;
    public static final int DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC         = 7;
    //
    public static final int DAPI_SPECIAL_COUNTER_LATCH_ALL                              = 1;
    public static final int DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET                   = 2;
    //
    public static final int DAPI_SPECIAL_CNT48_RESET_SINGLE                             = 1;
    public static final int DAPI_SPECIAL_CNT48_RESET_GROUP8                             = 2;
    public static final int DAPI_SPECIAL_CNT48_LATCH_GROUP8                             = 3;
    public static final int DAPI_SPECIAL_CNT48_DI_GET1                                  = 4;
    //
    public static final int DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE                         = 1;
    public static final int DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE                       = 2;
    public static final int DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS                       = 3;
    //
    public static final int DAPI_SPECIAL_PWM_FREQ_LOAD_DFAULT                           = 1;
    public static final int DAPI_SPECIAL_PWM_FREQ_SAVE_EEPROM                           = 2;
    public static final int DAPI_SPECIAL_PWM_FREQ_LOAD_EEPROM                           = 3;
    public static final int DAPI_SPECIAL_PWM_FREQ_SET                                   = 4;

    // values for PAR2
    public static final int DAPI_SPECIAL_AD_CH0_CH15                                    = 0;
    public static final int DAPI_SPECIAL_AD_CH16_CH31                                   = 1;
    public static final int DAPI_SPECIAL_AD_CH32_CH47                                   = 2;
    public static final int DAPI_SPECIAL_AD_CH48_CH63                                   = 3;

    // ----------------------------------------------------------------------------
    // DapiScanModules-Codes
    public static final int DAPI_SCANMODULE_GET_MODULES_AVAILABLE                       = 1;

    // ----------------------------------------------------------------------------
    // SOFTWARE Features Class
    public static final int DAPI_SW_CLASS_TYPE_OF_MODULE_IDENTIFICATION                 = (1<<0);           // Bit 0
    public static final int DAPI_SW_CLASS_DI_DO_DX_CHANNELS                             = (1<<1);           // Bit 1
    public static final int DAPI_SW_CLASS_AD_DA_CHANNELS                                = (1<<2);           // Bit 2

    // ----------------------------------------------------------------------------
    // Hardware Group
    public static final int DAPI_HW_GROUP_RO                                            = (1<<0);           // Bit 0
    public static final int DAPI_HW_GROUP_LOGICANALYZER                                 = (1<<1);           // Bit 1
    public static final int DAPI_HW_GROUP_DI_DO_AD_DA                                   = (1<<2);           // Bit 2
    public static final int DAPI_HW_GROUP_USB                                           = (1<<3);           // Bit 3
    public static final int DAPI_HW_GROUP_BS                                            = (1<<4);           // Bit 4
    public static final int DAPI_HW_GROUP_NET                                           = (1<<5);           // Bit 5
    public static final int DAPI_HW_GROUP_ETH                                           = (1<<6);           // Bit 6

    // --------------------------------------------------------
    // Software Feature Bits
    public static final int DAPI_SW_FEATURE_BIT_SUPPORTED_BY_FIRMWARE                   = 0x00000001;
    public static final int DAPI_SW_FEATURE_BIT_SOFTWARE_FIFO                           = 0x00000002;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DO_CMD_SET_CLR_BIT_32               = 0x00000004;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_RN23                             = 0x00000008;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_E2_2K                            = 0x00000020;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_E2_32K                           = 0x00000040;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_FS_SUPPORT                       = 0x00000080;
    public static final int DAPI_SW_FEATURE_BIT_DX_1_MODE                               = 0x00000010;
    public static final int DAPI_SW_FEATURE_BIT_AUTO_OUTPUTS_OFF_TIMEOUT                = 0x02000000;
    public static final int DAPI_SW_FEATURE_BIT_AUTO_OUTPUTS_OFF_TIMEOUT_WITH_MASK		= 0x00008000;
    public static final int DAPI_SW_FEATURE_BIT_SUPP_INDIVIDUAL_CH_NAMES                = 0x00001000;
    public static final int DAPI_SW_FEATURE_BIT_DEV_IO_REG_ERR_SUPP                     = 0x00002000;
    public static final int DAPI_SW_FEATURE_BIT_SUPP_SYSTEM_INFO                        = 0x00004000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_WATCHDOG                            = 0x10000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DI                                  = 0x20000000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DI_CNT                              = 0x40000000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DI_CNT_LATCH                        = 0x00080000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DI_FF                               = 0x80000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DO                                  = 0x01000000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DO_WITH_TIMER                       = 0x00040000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_PWM_OUT                             = 0x04000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DX                                  = 0x08000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DA                                  = 0x00100000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_AD                                  = 0x00200000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_CNT_OUT32                           = 0x00400000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_CNT_IN48                            = 0x00800000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_TEMP                                = 0x00010000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_STEPPER                             = 0x00020000;

    // --------------------------------------------------------
    // Hardware Interface Bits
    public static final int DAPI_HW_INTERFACE_BIT_SUPPORTED_BY_FIRMWARE                 = 0x00000001;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_ETH                               = 0x00000002;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_CAN                               = 0x00000004;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_RS232                             = 0x00000008;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_RS232_RS485                       = 0x00000010;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_USB1                              = 0x00000020;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_USB2                              = 0x00000040;

    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_MASK                           = 0xFF000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_RO                             = 0x01000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_RO2                            = 0x02000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_BS                             = 0x03000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_NET                            = 0x04000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_NET_IP                         = 0x05000000;

    // --------------------------------------------------------
    // TCP Feature Bits
    public static final int DAPI_TCP_FEATURE_BIT_SUPPORTED_BY_FIRMWARE                  = 0x00000001;
    public static final int DAPI_TCP_FEATURE_BIT_SUPP_RTC                               = 0x00000002;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Prototypes for DELIB-Functions
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------

    // ----------------------------------------------------------------------------
    // 
    public static native int DapiOpenModule(int moduleID, int nr);
    // left out (not possible): DapiOpenModuleEx
    public static native int DapiCloseModule(int handle);

    public static native int DapiScanModule(int moduleID, int cmd);
    public static native int DapiScanAllModulesAvailable(int todo);
    public static native int DapiScanAllModulesAvailableListEcecute(int nr, int todo);

    public static native int DapiGetDELIBVersion(int mode, int par);

    public static native int DapiPing(int handle, int value);

    // ----------------------------------------------------------------------------
    // Register Access
    public static native void DapiWriteByte(int handle, int adress, int value);
    public static native void DapiWriteWord(int handle, int adress, int value);
    public static native void DapiWriteLong(int handle, int adress, int value);
    public static native void DapiWriteLongLong(int handle, int adress, long value);

    public static native int DapiReadByte(int handle, int adress);
    public static native int DapiReadWord(int handle, int adress);
    public static native int DapiReadLong(int handle, int adress);
    public static native long DapiReadLongLong(int handle, int adress);

    // ----------------------------------------------------------------------------
    // Error Handling
    public static native int DapiGetLastError();
    // left out (not possible): DapiGetLastErrorText
    public static native void DapiClearLastError();

    // ----------------------------------------------------------------------------
    // Digital Inputs
    public static native int DapiDIGet1(int handle, int ch);
    public static native int DapiDIGet8(int handle, int ch);
    public static native int DapiDIGet16(int handle, int ch);
    public static native int DapiDIGet32(int handle, int ch);
    public static native long DapiDIGet64(int handle, int ch);  

    public static native int DapiDIGetFF32(int handle, int ch);

    public static native int DapiDIGetCounter(int handle, int ch, int mode);

    // ----------------------------------------------------------------------------
    // Digital Outputs
    public static native void DapiDOSet1(int handle, int ch, int data);
    public static native void DapiDOSet8(int handle, int ch, int data);
    public static native void DapiDOSet16(int handle, int ch, int data);
    public static native void DapiDOSet32(int handle, int ch, int data);
    public static native void DapiDOSet64(int handle, int ch, long data);

    public static native int DapiDOReadback32(int handle, int ch);
    public static native long DapiDOReadback64(int handle, int ch);

    public static native void DapiDOSet1_WithTimer(int handle, int ch, int data, int time_ms);
    public static native void DapiDOSetBit32(int handle, int ch, int data);
    public static native void DapiDOClrBit32(int handle, int ch, int data);

    // ----------------------------------------------------------------------------
    // Analog Inputs
    public static native int DapiADGet(int handle, int ch);
    // left out (not possible): DapiADGetValueModeUnit
    public static native float DapiADGetVolt(int handle, int ch);
    public static native float DapiADGetmA(int handle, int ch);
    public static native void DapiADSetMode(int handle, int ch, int mode);
    public static native int DapiADGetMode(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Analog Outputs
    public static native void DapiDASet(int handle, int ch, int data);
    public static native void DapiDASetVolt(int handle, int ch, float data);
    public static native void DapiDASetmA(int handle, int ch, float data);
    // left out (not possible): DapiDAGetValueModeUnit  
    public static native void DapiDASetMode(int handle, int ch, int mode);
    public static native int DapiDAGetMode(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Temperature Inputs
    public static native float DapiTempGet(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Counter48 Inputs
    public static native void DapiCnt48ModeSet(int handle, int ch, int mode);
    public static native int DapiCnt48ModeGet(int handle, int ch);
    public static native int DapiCnt48CounterGet32(int handle, int ch);
    public static native long DapiCnt48CounterGet48(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Pulse-Generator Outputs
    public static native void DapiPulseGenSet(int handle, int ch, int mode, int par0, int par1, int par2);

    // ----------------------------------------------------------------------------
    // PWM Outputs
    public static native void DapiPWMOutSet(int handle, int ch, float data);
    
    // ----------------------------------------------------------------------------
    // Stepper
    public static native int DapiStepperCommand(int handle, int motor, int cmd, int par1, int par2, int par3, int par4);
    public static native int DapiStepperCommandEx(int handle, int motor, int cmd, int par1, int par2, int par3, int par4, int par5, int par6, int par7);
    public static native int DapiStepperGetStatus(int handle, int motor, int cmd);

    // ----------------------------------------------------------------------------
    // Watchdog
    public static native void DapiWatchdogEnable(int handle);
    public static native void DapiWatchdogDisable(int handle);
    public static native void DapiWatchdogRetrigger(int handle);

    // ----------------------------------------------------------------------------
    // Fifo
    // left out (not possible): DapiReadFifo

    // ----------------------------------------------------------------------------
    // CAN
    // left out (not possible): DAPI_CAN_MESSAGE_STRUCT
    // left out (not possible): DapiCANCommand
    // left out (not possible): DapiCANGetPacket
    // left out (not possible): DapiCANSendPacket

    // ----------------------------------------------------------------------------
    // Special
    public static native int DapiSpecialCommand(int handle, int cmd, int par1, int par2, int par3);
    // left out (not possible): DapiSpecialCommandExt

    // left out (not possible): DapiReadMultipleBytes
    // left out (not possible): DapiWriteMultipleBytes

    // ----------------------------------------------------------------------------
    // DI - Counter Mode
    public static final int DAPI_CNT_MODE_READ                              = 0x00;
    public static final int DAPI_CNT_MODE_READ_WITH_RESET                   = 0x01;
    public static final int DAPI_CNT_MODE_READ_LATCHED                      = 0x02;

    // ----------------------------------------------------------------------------
    // A/D and D/A Modes
    public static final int DAPI_ADDA_MODE_UNIPOL_10V                       = 0x00;
    public static final int DAPI_ADDA_MODE_UNIPOL_5V                        = 0x01;
    public static final int DAPI_ADDA_MODE_UNIPOL_2V5                       = 0x02;

    public static final int DAPI_ADDA_MODE_BIPOL_10V                        = 0x40;
    public static final int DAPI_ADDA_MODE_BIPOL_5V                         = 0x41;
    public static final int DAPI_ADDA_MODE_BIPOL_2V5                        = 0x42;

    public static final int DAPI_ADDA_MODE_0_20mA                           = 0x80;
    public static final int DAPI_ADDA_MODE_4_20mA                           = 0x81;
    public static final int DAPI_ADDA_MODE_0_24mA                           = 0x82;
    //public static final int DAPI_ADDA_MODE_0_25mA                         = 0x83;
    public static final int DAPI_ADDA_MODE_0_50mA                           = 0x84;

    public static final int DAPI_ADDA_MODE_BI_CAL_MODE                      = 0xfd;
    public static final int DAPI_ADDA_MODE_0_20mA_TESTMODE                  = 0xfe;
    public static final int DAPI_ADDA_MODE_BIPOL_10V_TESTMODE               = 0xff;

    public static final int DAPI_ADDA_MODE_DA_DISABLE                       = 0x100;
    public static final int DAPI_ADDA_MODE_DA_ENABLE                        = 0x200;

    public static final int DAPI_ADDA_MODE_PREVENT_DAPI_MODE_ERROR          = 0x8000;

    // --------------------------------------------------------
    // A/D and D/A units
    public static final int DAPI_ADDA_UNIT_ILLEGAL                          = 0x00;
    public static final int DAPI_ADDA_UNIT_VOLT                             = 0x01;
    public static final int DAPI_ADDA_UNIT_MA                               = 0x02;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Stepper-Defines

    // ------------------------------------
    // ERROR Codes
    public static final int DAPI_STEPPER_ERR_NONE                           = 0;                // es liegt kein Fehler vor 
    public static final int DAPI_STEPPER_ERR_PARAMETER                      = 1;                // Parameter hat falschen Wertebereich 
    public static final int DAPI_STEPPER_ERR_MOTOR_MOVE                     = 2;                // Kommando abgelehnt, da sich der Motor dreht
    public static final int DAPI_STEPPER_ERR_DISABLE_MOVE                   = 3;                // Kommando abgehelnt, da Motorbewegung disabled ist
    public static final int DAPI_STEPPER_ERR_DEVICE_NOT_FOUND               = -1;       // es liegt kein Fehler vor 

    // ------------------------------------
    // Special Stepper Function-Codes
    public static final int DAPI_STEPPER_RETURN_0_BYTES                     = 0x00000000;       // Kommando schickt 0 Byte als Antwort
    public static final int DAPI_STEPPER_RETURN_1_BYTES                     = 0x40000000;       // Kommando schickt 1 Byte als Antwort
    public static final int DAPI_STEPPER_RETURN_2_BYTES                     = 0x80000000;       // Kommando schickt 2 Byte als Antwort
    public static final int DAPI_STEPPER_RETURN_4_BYTES                     = 0xc0000000;       // Kommando schickt 4 Byte als Antwort

    public static final int DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC                = ( 0x00000001 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_GET_MOTORCHARACTERISTIC                = ( 0x00000002 + DAPI_STEPPER_RETURN_4_BYTES ); 
    public static final int DAPI_STEPPER_CMD_SET_POSITION                           = ( 0x00000003 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GO_POSITION                            = ( 0x00000004 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GET_POSITION                           = ( 0x00000005 + DAPI_STEPPER_RETURN_4_BYTES );  
    public static final int DAPI_STEPPER_CMD_SET_FREQUENCY                          = ( 0x00000006 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_SET_FREQUENCY_DIRECTLY                 = ( 0x00000007 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GET_FREQUENCY                          = ( 0x00000008 + DAPI_STEPPER_RETURN_2_BYTES );  
    public static final int DAPI_STEPPER_CMD_FULLSTOP                               = ( 0x00000009 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_STOP                                   = ( 0x00000010 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GO_REFSWITCH                           = ( 0x00000011 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_DISABLE                                = ( 0x00000014 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_LOAD_DEFAULT       = ( 0x00000015 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_SAVE        = ( 0x00000016 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_LOAD        = ( 0x00000017 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_GET_CPU_TEMP                           = ( 0x00000018 + DAPI_STEPPER_RETURN_1_BYTES );
    public static final int DAPI_STEPPER_CMD_GET_MOTOR_SUPPLY_VOLTAGE               = ( 0x00000019 + DAPI_STEPPER_RETURN_2_BYTES );
    public static final int DAPI_STEPPER_CMD_GO_POSITION_RELATIVE                   = ( 0x00000020 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_EEPROM_ERASE                           = ( 0x00000021 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_SET_VECTORMODE                         = ( 0x00000040 + DAPI_STEPPER_RETURN_0_BYTES );  

    // ------------------------------------
    // values for PAR1 for DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STEPMODE                             = 1;    // Schrittmode (Voll-, Halb-, Viertel-, Achtel-, Sechszehntelschritt 
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOFREQUENCY                          = 2;    // Schrittfrequenz bei GoPosition [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STARTFREQUENCY                       = 3;    // Startfrequenz [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STOPFREQUENCY                        = 4;    // Stopfrequenz [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_MAXFREQUENCY                         = 5;    // maximale Frequenz [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_ACCELERATIONSLOPE                    = 6;    // Beschleunigung in [Vollschritten / ms]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_DECELERATIONSLOPE                    = 7;    // Bremsung in [Vollschritten / ms]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_PHASECURRENT                         = 8;    // Phasenstrom [mA]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_HOLDPHASECURRENT                     = 9;    // Phasenstrom bei Motorstillstand [mA]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_HOLDTIME                             = 10;   // Zeit in der der Haltestrom fliet nach Motorstop [s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STATUSLEDMODE                        = 11;   // Betriebsart der Status-LED
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW1                        = 12;   // invertiere Funktion des Endschalter1  
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW2                        = 13;   // invertiere Funktion des Endschalter12 
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW1                        = 14;   // invertiere Funktion des Referenzschalterschalter1
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW2                        = 15;   // invertiere Funktion des Referenzschalterschalter2
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_DIRECTION                     = 16;   // invertiere alle Richtungsangaben
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_ENDSWITCH_STOPMODE                   = 17;   // Bei Endschalter soll (0=full stop/1=stop mit rampe)
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOENDSWITCH     = 18;   // Motor Frequency for GoReferenceCommand
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_AFTERENDSWITCH  = 19;   // Motor Frequency for GoReferenceCommand
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOOFFSET        = 20;   // Motor Frequency for GoReferenceCommand

    // ----------------------------------------------------------------------------
    // values for PAR1 for DAPI_STEPPER_CMD_GO_REFSWITCH
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF1                  = 1;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF2                  = 2;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_LEFT              = 4;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_RIGHT             = 8;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_POSITIVE       = 16;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_NEGATIVE       = 32;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_SET_POS_0             = 64;

    // ------------------------------------
    // Stepper Read Status
    public static final int DAPI_STEPPER_STATUS_GET_POSITION                    = 0x01;
    public static final int DAPI_STEPPER_STATUS_GET_SWITCH                      = 0x02;
    public static final int DAPI_STEPPER_STATUS_GET_ACTIVITY                    = 0x03;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // CAN-Defines

    // ------------------------------------
    // CAN Commands
    public static final int DAPI_CAN_CMD_SET_BITRATE            = 1;
    public static final int DAPI_CAN_CMD_SET_MASK0              = 2;
    public static final int DAPI_CAN_CMD_SET_RX_ADDRESS         = 3;
    public static final int DAPI_CAN_CMD_CLR_TIMESTAMP          = 4;
    public static final int DAPI_CAN_CMD_GET_BITRATE            = 5;
    public static final int DAPI_CAN_CMD_GET_TIMESTAMP          = 6;

    public static final int DAPI_CAN_CMD_TEST_GEN_RX_PACK       = 0xfffffff0;

    public static final int DAPI_PAR_CAN_MESSAGE_BOX_0          = 0;
    public static final int DAPI_PAR_CAN_MESSAGE_BOX_1          = 1;
    public static final int DAPI_PAR_CAN_MESSAGE_BOX_2          = 2;
    public static final int DAPI_PAR_CAN_MESSAGE_BOX_3          = 3;

    public static final int DAPI_CAN_BITRATE_10000              = 10000;
    public static final int DAPI_CAN_BITRATE_20000              = 20000;
    public static final int DAPI_CAN_BITRATE_50000              = 50000;
    public static final int DAPI_CAN_BITRATE_100000             = 100000;
    public static final int DAPI_CAN_BITRATE_125000             = 125000;
    public static final int DAPI_CAN_BITRATE_250000             = 250000;
    public static final int DAPI_CAN_BITRATE_500000             = 500000;
    public static final int DAPI_CAN_BITRATE_1000000            = 1000000;

    public static final int DAPI_CAN_MASK_SINGLE                = 0xffffffff;
    public static final int DAPI_CAN_MASK_ALL                   = 0x0;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // CNT48 Commands

    public static final int DAPI_CNT48_FILTER_20ns              = 0x0000;
    public static final int DAPI_CNT48_FILTER_100ns             = 0x1000;
    public static final int DAPI_CNT48_FILTER_250ns             = 0x2000;
    public static final int DAPI_CNT48_FILTER_500ns             = 0x3000;
    public static final int DAPI_CNT48_FILTER_1us               = 0x4000;
    public static final int DAPI_CNT48_FILTER_2_5us             = 0x5000;
    public static final int DAPI_CNT48_FILTER_5us               = 0x6000;
    public static final int DAPI_CNT48_FILTER_10us              = 0x7000;
    public static final int DAPI_CNT48_FILTER_25us              = 0x8000;
    public static final int DAPI_CNT48_FILTER_50us              = 0x9000;
    public static final int DAPI_CNT48_FILTER_100us             = 0xA000;
    public static final int DAPI_CNT48_FILTER_250us             = 0xB000;
    public static final int DAPI_CNT48_FILTER_500us             = 0xC000;
    public static final int DAPI_CNT48_FILTER_1ms               = 0xD000;
    public static final int DAPI_CNT48_FILTER_2_5ms             = 0xE000;
    public static final int DAPI_CNT48_FILTER_5ms               = 0xF000;

    public static final int DAPI_CNT48_MODE_COUNT_RISING_EDGE                   = 0x0000;
    public static final int DAPI_CNT48_MODE_COUNT_RISING_EDGE_X2                = 0x0001;
    public static final int DAPI_CNT48_MODE_COUNT_RISING_EDGE_X4                = 0x0002;
    public static final int DAPI_CNT48_MODE_T                                   = 0x000D;
    public static final int DAPI_CNT48_MODE_FREQUENCY                           = 0x000E;
    public static final int DAPI_CNT48_MODE_PWM                                 = 0x000F;

    public static final int DAPI_CNT48_SUBMODE_NO_RESET                         = 0x0000;
    public static final int DAPI_CNT48_SUBMODE_RESET_WITH_READ                  = 0x0010;
    public static final int DAPI_CNT48_SUBMODE_NO_RESET_NO_HW_RESET             = 0x0020;
    public static final int DAPI_CNT48_SUBMODE_RESET_WITH_READ_NO_HW_RESET      = 0x0030;
    public static final int DAPI_CNT48_SUBMODE_RESET_ON_CH_7                    = 0x0070;
    public static final int DAPI_CNT48_SUBMODE_LATCH_COMMON                     = 0x0080;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_1ms          = 0x0030;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_10ms         = 0x0020;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_100ms        = 0x0010;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_1sec         = 0x0000;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Software FIFO Commands

    public static final int DAPI_FIFO_TYPE_READ_AD_FIFO                         = 0x01;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // PWM Commands

    public static final int DAPI_PWM_FREQUENCY_10HZ                             = 1;
    public static final int DAPI_PWM_FREQUENCY_100HZ                            = 10;
    public static final int DAPI_PWM_FREQUENCY_250HZ                            = 25;
    public static final int DAPI_PWM_FREQUENCY_1000HZ                           = 100;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Definitions for DapiOpenEx

    // left out (not possible): DAPI_OPENMODULEEX_STRUCT;

    public static final int DAPI_OPEN_MODULE_OPTION_USE_EXBUFFER                = (1<<0);   // Bit 0
    public static final int DAPI_OPEN_MODULE_OPTION_NO_RESCAN                   = (1<<1);   // Bit 1

    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_NONE               = 0;
    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_NORMAL             = 1;
    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_ADMIN              = 2;
    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_ADMIN_TEMP         = 3;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
}



- Delib.java
  Inhalt:
package DelibJava;

//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//
//
//
//  Delib.java
//  project: DELIB
//
//
//  (c) DEDITEC GmbH, 2009-2016
//  web: http://www.deditec.de/
//  mail: vertrieb@deditec.de
//
//
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.net.InetSocketAddress;
import java.net.Socket;

public class Delib 
{
	// ----------------------------------------------------------------------------
	// Private global vars
	private int job_id = 0;
	private Socket socket;
	private InputStream input_stream;
	private OutputStream output_stream;
	private byte[] tx_buffer = new byte[256];
	private int amount_bytes_received;
	private byte[] rx_buffer = new byte[256];
	private byte[] global_ad_buffer = new byte[128*4];	// Max 128 chan
	private long dapi_last_error = 0;
	private String dapi_last_error_text;

	// ----------------------------------------------------------------------------	
	// Intern
	// ----------------------------------------------------------------------------	
	private static final long DEDITEC_TCP_START_ID_FOR_MULTIPLE_BYTE_DATA			= 35;
	// ----------------------------------------------------------------------------	
	private static final long DEDITEC_PACKET_ID_0									= 0x63;
	private static final long DEDITEC_PACKET_ID_1									= 0x9a;
	private static final long DEDITEC_TCP_ANSWER_RO_1								= 0x81;
	private static final long DEDITEC_TCP_ANSWER_OK									= 0;
	// ----------------------------------------------------------------------------	
	// RO-FIFO Commands
	private static final long RO_FIFO_CMD_fifo_init 								= 1;
	private static final long RO_FIFO_CMD_fifo_set_intervalL						= 2;
	private static final long RO_FIFO_CMD_fifo_set_intervalH						= 3;
	private static final long RO_FIFO_CMD_fifo_enable_chL							= 4;
	private static final long RO_FIFO_CMD_fifo_enable_chH							= 5;
	private static final long RO_FIFO_CMD_fifo_enable_disable						= 6;
	
	// ----------------------------------------------------------------------------
	// ERROR Codes
	public static final long DAPI_ERR_NONE											= 0;
	public static final long DAPI_ERR_DEVICE_NOT_FOUND								= -1;
	public static final long DAPI_ERR_COMMUNICATION_ERROR							= -2;
	public static final long DAPI_ERR_ILLEGAL_HANDLE								= -10;
	public static final long DAPI_ERR_FUNCTION_NOT_DEFINED							= -11;
	public static final long DAPI_ERR_ILLEGAL_COM_HANDLE							= -12;
	public static final long DAPI_ERR_ILLEGAL_MODE									= -13;
	public static final long DAPI_ERR_WITH_TEXT										= -14;
	public static final long DAPI_ERR_SW_FEATURE_NOT_SUPPORTED						= -15;
	public static final long DAPI_ERR_ILLEGAL_IO_TYPE								= -16;
	public static final long DAPI_ERR_ILLEGAL_CHANNEL								= -17;

	// ----------------------------------------------------------------------------
	// Special Function-Codes
	public static final long DAPI_SPECIAL_CMD_GET_MODULE_CONFIG						= 1;
	public static final long DAPI_SPECIAL_CMD_TIMEOUT								= 2;
	public static final long DAPI_SPECIAL_CMD_DI									= 10;
	public static final long DAPI_SPECIAL_CMD_SET_DIR_DX_1							= 3;
	public static final long DAPI_SPECIAL_CMD_SET_DIR_DX_8							= 4;
	public static final long DAPI_SPECIAL_CMD_GET_MODULE_VERSION					= 5;
	public static final long DAPI_SPECIAL_CMD_DA									= 6;
	public static final long DAPI_SPECIAL_CMD_WATCHDOG								= 7;
	public static final long DAPI_SPECIAL_CMD_COUNTER								= 8;
	public static final long DAPI_SPECIAL_CMD_AD									= 9;
	public static final long DAPI_SPECIAL_CMD_CNT48									= 11;
	public static final long DAPI_SPECIAL_CMD_SOFTWARE_FIFO							= 12;
	public static final long DAPI_SPECIAL_CMD_MODULE_REBOOT							= 13;
	public static final long DAPI_SPECIAL_CMD_MODULE_RESCAN							= 14;
	public static final long DAPI_SPECIAL_CMD_RESTART_CHECK_MODULE_CONFIG			= 15;

	// values for PAR1
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI					= 1;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF				= 7;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER			= 8;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO					= 2;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX					= 3;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD					= 4;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA					= 5;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP				= 9;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER				= 6;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48				= 10;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN			= 11;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT				= 12;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_INTERFACE1		= 13;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_FEATURE1			= 14;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_GROUP			= 15;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_CLASS			= 16;
	//
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0					= 0;
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1					= 1;
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2					= 2;
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3					= 3;
	//
	public static final long DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC						= 1;
	public static final long DAPI_SPECIAL_TIMEOUT_ACTIVATE							= 2;
	public static final long DAPI_SPECIAL_TIMEOUT_DEACTIVATE						= 3;
	public static final long DAPI_SPECIAL_TIMEOUT_GET_STATUS						= 4;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_LOAD_DEFAULT				= 5;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_CLR32			= 6;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_CLR32			= 7;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_SET32			= 8;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_SET32			= 9;
	//
	public static final long DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET					= 1;
	public static final long DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET					= 2;
	//
	public static final long DAPI_SPECIAL_AD_READ_MULTIPLE_AD						= 1;
	public static final long DAPI_SPECIAL_AD_FIFO_ACTIVATE							= 2;
	public static final long DAPI_SPECIAL_AD_FIFO_DEACTIVATE						= 3;
	public static final long DAPI_SPECIAL_AD_FIFO_GET_STATUS						= 4;
	public static final long DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS					= 5;
	public static final long DAPI_SPECIAL_AD_FIFO_SET_CHANNEL						= 6;
	public static final long DAPI_SPECIAL_AD_FIFO_INIT								= 7;
	public static final long DAPI_SPECIAL_AD_FILTER_SET								= 8;
	public static final long DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT					= 1;
	public static final long DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG				= 2;
	public static final long DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG				= 3;
	//
	public static final long DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC					= 1;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC					= 2;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_STATUS						= 3;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC				= 4;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC	= 5;
	public static final long DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC	= 6;
	public static final long DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC	= 7;
	//
	public static final long DAPI_SPECIAL_COUNTER_LATCH_ALL							= 1;
	public static final long DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET				= 2;
	//
	public static final long DAPI_SPECIAL_CNT48_RESET_SINGLE						= 1;
	public static final long DAPI_SPECIAL_CNT48_RESET_GROUP8						= 2;
	public static final long DAPI_SPECIAL_CNT48_LATCH_GROUP8						= 3;
	public static final long DAPI_SPECIAL_CNT48_DI_GET1								= 4;
	//
	public static final long DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE					= 1;
	public static final long DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE					= 2;
	public static final long DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS					= 3;

	// values for PAR2
	public static final long DAPI_SPECIAL_AD_CH0_CH15								= 0;
	public static final long DAPI_SPECIAL_AD_CH16_CH31								= 1;

	// ----------------------------------------------------------------------------
	// DapiScanModules-Codes
	public static final long DAPI_SCANMODULE_GET_MODULES_AVAILABLE					= 1;

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// DI - Counter Mode

	public static final long DAPI_CNT_MODE_READ_WITH_RESET							= 0x01; 
	public static final long DAPI_CNT_MODE_READ_LATCHED								= 0x02;
	public static final long DAPI_SW_CLASS_AD_DA_CHANNELS							= 0x04;

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// A/D and D/A Modes
	
	public static final long ADDA_MODE_UNIPOL_10V 									= 0x00;
	public static final long ADDA_MODE_UNIPOL_5V 									= 0x01;
	public static final long ADDA_MODE_UNIPOL_2V5 									= 0x02;
	
	public static final long ADDA_MODE_BIPOL_10V 									= 0x40;
	public static final long ADDA_MODE_BIPOL_5V 									= 0x41;
	public static final long ADDA_MODE_BIPOL_2V5 									= 0x42;
	
	public static final long ADDA_MODE_0_20mA 										= 0x80;
	public static final long ADDA_MODE_4_20mA										= 0x81;
	public static final long ADDA_MODE_0_24mA 										= 0x82;

	public static final long ADDA_MODE_DA_DISABLE 									= 0x100;
	public static final long ADDA_MODE_DA_ENABLE 									= 0x200;
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// Stepper-Defines

	// ------------------------------------
	// ERROR Codes
	public static final long DAPI_STEPPER_ERR_NONE									= 0;		// es liegt kein Fehler vor 
	public static final long DAPI_STEPPER_ERR_PARAMETER								= 1;		// Parameter hat falschen Wertebereich 
	public static final long DAPI_STEPPER_ERR_MOTOR_MOVE							= 2;		// Kommando abgelehnt, da sich der Motor dreht
	public static final long DAPI_STEPPER_ERR_DISABLE_MOVE							= 3;		// Kommando abgehelnt, da Motorbewegung disabled ist
	public static final long DAPI_STEPPER_ERR_DEVICE_NOT_FOUND						= -1;		// es liegt kein Fehler vor 

	// ------------------------------------
	// Special Stepper Function-Codes
	public static final long DAPI_STEPPER_RETURN_0_BYTES 							= 0x00000000;		// Kommando schickt 0 Byte als Antwort
	public static final long DAPI_STEPPER_RETURN_1_BYTES 							= 0x40000000;		// Kommando schickt 1 Byte als Antwort
	public static final long DAPI_STEPPER_RETURN_2_BYTES 							= 0x80000000;		// Kommando schickt 2 Byte als Antwort
	public static final long DAPI_STEPPER_RETURN_4_BYTES 							= 0xc0000000;		// Kommando schickt 4 Byte als Antwort

	public static final long DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC               = ( 0x00000001 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GET_MOTORCHARACTERISTIC               = ( 0x00000002 + DAPI_STEPPER_RETURN_4_BYTES ); 
	public static final long DAPI_STEPPER_CMD_SET_POSITION                          = ( 0x00000003 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GO_POSITION                           = ( 0x00000004 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GET_POSITION                          = ( 0x00000005 + DAPI_STEPPER_RETURN_4_BYTES );  
	public static final long DAPI_STEPPER_CMD_SET_FREQUENCY                         = ( 0x00000006 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_SET_FREQUENCY_DIRECTLY                = ( 0x00000007 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GET_FREQUENCY                         = ( 0x00000008 + DAPI_STEPPER_RETURN_2_BYTES );  
	public static final long DAPI_STEPPER_CMD_FULLSTOP                              = ( 0x00000009 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_STOP                                  = ( 0x00000010 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GO_REFSWITCH                          = ( 0x00000011 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_DISABLE                               = ( 0x00000014 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_LOAD_DEFAULT		= ( 0x00000015 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_SAVE		= ( 0x00000016 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_LOAD		= ( 0x00000017 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_GET_CPU_TEMP							= ( 0x00000018 + DAPI_STEPPER_RETURN_1_BYTES );
	public static final long DAPI_STEPPER_CMD_GET_MOTOR_SUPPLY_VOLTAGE				= ( 0x00000019 + DAPI_STEPPER_RETURN_2_BYTES );
	public static final long DAPI_STEPPER_CMD_GO_POSITION_RELATIVE                  = ( 0x00000020 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_EEPROM_ERASE							= ( 0x00000021 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_SET_VECTORMODE                        = ( 0x00000040 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_GET_STATUS                            = ( 0x00000015 + DAPI_STEPPER_RETURN_1_BYTES );

	// ------------------------------------
	// values for PAR1 for DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC

	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STEPMODE					= 1;					// Schrittmode (Voll-, Halb-, Viertel-, Achtel-, Sechszehntelschritt 
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOFREQUENCY					= 2;					// Schrittfrequenz bei GoPosition [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STARTFREQUENCY				= 3;					// Startfrequenz [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STOPFREQUENCY				= 4;					// Stopfrequenz [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_MAXFREQUENCY				= 5;					// maximale Frequenz [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_ACCELERATIONSLOPE			= 6;					// Beschleunigung in [Vollschritten / ms]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_DECELERATIONSLOPE			= 7;					// Bremsung in [Vollschritten / ms]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_PHASECURRENT				= 8;					// Phasenstrom [mA]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_HOLDPHASECURRENT			= 9;					// Phasenstrom bei Motorstillstand [mA]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_HOLDTIME 					= 10;					// Zeit in der der Haltestrom flie�t nach Motorstop [s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STATUSLEDMODE				= 11;					// Betriebsart der Status-LED
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW1				= 12;					// invertiere Funktion des Endschalter1  
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW2				= 13;					// invertiere Funktion des Endschalter12 
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW1				= 14;					// invertiere Funktion des Referenzschalterschalter1
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW2				= 15;					// invertiere Funktion des Referenzschalterschalter2
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_DIRECTION 			= 16;					// invertiere alle Richtungsangaben
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_ENDSWITCH_STOPMODE			= 17;					// Bei Endschalter soll (0=full stop/1=stop mit rampe)
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOENDSWITCH	= 18;			// Motor Frequency for GoReferenceCommand
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_AFTERENDSWITCH	= 19;			// Motor Frequency for GoReferenceCommand
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOOFFSET 		= 20;			// Motor Frequency for GoReferenceCommand

	// ----------------------------------------------------------------------------
	// values for PAR1 for DAPI_STEPPER_CMD_GO_REFSWITCH

	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF1						= 1;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF2						= 2;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_LEFT					= 4;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_RIGHT				= 8;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_POSITIVE			= 16;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_NEGATIVE			= 32;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_SET_POS_0				= 64;

	// ------------------------------------
	// Stepper Read Status
	
	public static final long DAPI_STEPPER_STATUS_GET_POSITION						= 0x01;
	public static final long DAPI_STEPPER_STATUS_GET_SWITCH							= 0x02;
	public static final long DAPI_STEPPER_STATUS_GET_ACTIVITY						= 0x03;
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// CNT48 Commands

	public static final long DAPI_CNT48_FILTER_20ns									= 0x0000;
	public static final long DAPI_CNT48_FILTER_100ns								= 0x1000;
	public static final long DAPI_CNT48_FILTER_250ns								= 0x2000;
	public static final long DAPI_CNT48_FILTER_500ns								= 0x3000;
	public static final long DAPI_CNT48_FILTER_1us									= 0x4000;
	public static final long DAPI_CNT48_FILTER_2_5us								= 0x5000;
	public static final long DAPI_CNT48_FILTER_5us									= 0x6000;
	public static final long DAPI_CNT48_FILTER_10us									= 0x7000;
	public static final long DAPI_CNT48_FILTER_25us									= 0x8000;
	public static final long DAPI_CNT48_FILTER_50us									= 0x9000;
	public static final long DAPI_CNT48_FILTER_100us								= 0xA000;
	public static final long DAPI_CNT48_FILTER_250us								= 0xB000;
	public static final long DAPI_CNT48_FILTER_500us								= 0xC000;
	public static final long DAPI_CNT48_FILTER_1ms									= 0xD000;
	public static final long DAPI_CNT48_FILTER_2_5ms								= 0xE000;
	public static final long DAPI_CNT48_FILTER_5ms									= 0xF000;

	public static final long DAPI_CNT48_MODE_COUNT_RISING_EDGE						= 0x0000;
	public static final long DAPI_CNT48_MODE_T										= 0x000D;
	public static final long DAPI_CNT48_MODE_FREQUENCY								= 0x000E;
	public static final long DAPI_CNT48_MODE_PWM									= 0x000F;

	public static final long DAPI_CNT48_SUBMODE_NO_RESET							= 0x0000;
	public static final long DAPI_CNT48_SUBMODE_RESET_WITH_READ 					= 0x0010;
	public static final long DAPI_CNT48_SUBMODE_RESET_ON_CH_7 						= 0x0070;
	public static final long DAPI_CNT48_SUBMODE_LATCH_COMMON 						= 0x0080;

	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// DELIB-Functions
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// Management
	
	public long DapiOpenModuleEx(String ipAdresseDeditec, long portNoDeditec, long timeout_ms) throws Exception
	{
		try 
		{	
			// set input_socket settings
			socket = new Socket();
			socket.connect(new InetSocketAddress(ipAdresseDeditec, (int) portNoDeditec), (int) timeout_ms);
			
		    // set input/output stream to SOCKETcket
		    input_stream = socket.getInputStream();
		    output_stream = socket.getOutputStream();
		}
		finally {}
		
		long handle = 0x1234;
		return handle;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiCloseModule() throws Exception
	{
		try 
		{
			socket.close();
		}
		finally {}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// Register Access
	
	
	public void DapiDOSet1_WithTimer(long handle, long ch, long data, long time_ms)
	{
		DapiWriteLong(handle, 0x200, time_ms);
		DapiWriteWord(handle, 0x204, (ch << 8) | data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet1(long handle, long ch, long data)
	{
		long xx;
		long mask;
	
		xx = DapiDOReadback32(handle, ch&0xffe0);
	
		mask = 1 << (ch&31);
	
		if(data == 0)
		{
			// clear Bit
			xx = xx & (~mask);
		}
		else
		{
			// set Bit
			xx = xx | mask;
		}
	
		DapiDOSet32(handle, ch&0xffe0, xx);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet8(long handle, long ch, long data)
	{					
		DapiWriteByte(handle, (ch>>3) & 0x1f, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet16(long handle, long ch, long data)
	{
		DapiWriteWord(handle, (ch>>3) & (~1) & 0x1f, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet32(long handle, long ch, long data)
	{
		DapiWriteLong(handle, (ch>>3) & (~3) & 0x1f, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet1(long handle, long ch)
	{
		long xx;
		long mask;
	
		xx = DapiDIGet8(handle, ch&0xfff8);
	
		mask = 1 << (ch&7);
		if((xx&mask) == 0)
		{
			return 0;
		}
		else
		{
			return 1;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet8(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadByte(handle, 0x20 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet16(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadWord(handle, 0x20 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet32(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadLong(handle, 0x20 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGetFF32(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadLong(handle, 0x40 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGetCounter(long handle, long ch, long mode)
	{
		long adr;
		long ret;
	
		adr = 0x100 + (ch&0x1f)*2;
		if(mode == DAPI_CNT_MODE_READ_WITH_RESET)
		{
			adr+=0x100;
		}
		else if(mode == DAPI_CNT_MODE_READ_LATCHED)
		{
			adr+=0x200;
		}
	
		ret = DapiReadWord(handle, adr);
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDOReadback32(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadLong(handle, (ch>>3) & 0x1f);
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiADSetMode(long handle, long ch, long mode)
	{
		DapiWriteByte(handle, 0x1000 + ch*4 + 3, mode);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiADGetMode(long handle, long ch)
	{
		return DapiReadByte(handle, 0x1000 + ch*4 + 3);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiADGet(long handle, long ch)
	{
		long ret;
	
		if ((ch & 0x8000) == 0)
		{
			return DapiReadWord(handle, 0x1000 + ch*4);
		}
		else
		{
			ret  = ((long) global_ad_buffer[(int) ((ch&63) * 4) + 0]);
			ret |= ((long) global_ad_buffer[(int) ((ch&63) * 4) + 1]) << 8;
			return ret;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public float DapiADGetVolt(long handle, long ch)
	{
		long data;
		long mode;
		float value=0;
	
		if ((ch & 0x8000) == 0)
		{
			data = DapiReadLong(handle, 0x1000 + ch*4);
		}
		else
		{
			data = ((long) global_ad_buffer[(int) ((ch&127) * 4) + 0]);
			data|= ((long) global_ad_buffer[(int) ((ch&127) * 4) + 1]) << 8;
			data|= ((long) global_ad_buffer[(int) ((ch&127) * 4) + 2]) << 16;
			data|= ((long) global_ad_buffer[(int) ((ch&127) * 4) + 3]) << 24;
		}
	
		mode = (data >> 24) & 0xff;
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_UNIPOL_10V:
				// 0-10V
				value = (((float) (data&0xffff)) *10.0F / 65536.0F);
				break;
	
			case (int) ADDA_MODE_UNIPOL_5V:
				// 0-5V
				value = (((float) (data&0xffff)) *5.0F / 65536.0F);
				break;
	
			case (int) ADDA_MODE_BIPOL_10V:
				// +-10V
				value = (((float) (data&0xffff)) *20.0F / 65536.0F) - 10.0F;
				break;
	
			case (int) ADDA_MODE_BIPOL_5V:
				// +-5V
				value = (((float) (data&0xffff)) *10.0F / 65536.0F) - 5.0F;
				break;
	
			default:					
				break;
		}
		return value;
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public float DapiADGetmA(long handle, long ch)
	{
		long data;
		long mode;
		float value=0;
	
		if ((ch & 0x8000) == 0)
		{
			data = DapiReadLong(handle, 0x1000 + ch*4);
		}
		else
		{
			data = global_ad_buffer[(int) ch&63];
		}
	
	
		mode = data >> 24;
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_0_24mA:
			case (int) ADDA_MODE_0_20mA:
			case (int) ADDA_MODE_4_20mA:
				// 0-5V entspricht 0-25mA (100 Ohm) und Spannungsverdopplung !
				value = (((float) (data&0xffff)) *25.0F / 65536.0F);
				break;
	
			default:			
				break;
	
		}
	
		
		return value;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASetMode(long handle, long ch, long mode)
	{
		DapiWriteByte(handle, 0x2000 + ch*8 + 2, mode&255);
	
		if((mode & ADDA_MODE_DA_DISABLE) == ADDA_MODE_DA_DISABLE)
		{
			DapiWriteByte(handle, 0x2000 + ch*8 + 3, 1);	// Disable D/A Channel
		}
		if((mode & ADDA_MODE_DA_ENABLE) == ADDA_MODE_DA_ENABLE)
		{
			DapiWriteByte(handle, 0x2000 + ch*8 + 3, 0);	// Enable D/A Channel
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDAGetMode(long handle, long ch)
	{
		return DapiReadByte(handle, 0x2000 + ch*8 + 2);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASet(long handle, long ch, long data)
	{
		DapiWriteWord(handle, 0x2000 + ch*8, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASetVolt(long handle, long ch, float volt)
	{
		long mode;
		long value;
		mode = 	DapiDAGetMode(handle, ch);
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_UNIPOL_10V:
				value = (long) (3276.8 *2.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			case (int) ADDA_MODE_UNIPOL_5V:
				value = (long) (3276.8 * 4.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_UNIPOL_2V5:
				value = (long) (3276.8 * 8.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_BIPOL_10V:
				value = (long) (32768.0 + 3276.8 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_BIPOL_5V:
				value = (long) (32768.0 + 3276.8 * 2.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			case (int) ADDA_MODE_BIPOL_2V5:
				value = (long) (32768.0 + 3276.8 * 4.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			default:	
				break;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASetmA(long handle, long ch, float data)
	{
		long mode;
		long value;
	
		mode = 	DapiDAGetMode(handle, ch);
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_0_20mA:
				if(data<0) data=0;
				value = (long) (3276.8 * data);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			case (int) ADDA_MODE_4_20mA:
				if(data<4) data=4;
				value = (long) (4096 * (data-4.0));
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_0_24mA:
				if(data<4) data=4;
				value = (long) (65536/24 * data);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			default:			
				break;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public float DapiTempGet(long handle, long ch)
	{
		float f;
		long d;
		
		if((ch&0x8000) == 0)
		{
			// Temperatur soll gelesen werden
			d = DapiReadLong(handle, 0x4000 + ch*8);
	
			switch((int) (d>>16) & 0xff)
			{
				case 1:	f = ((float) (d&0x7fff)) / 10;break;				// Faktor 10
				case 2:	f = ((float) (d&0x7fff)) / 100;break;				// Faktor 100
				case 0:	f = -9999;break;									// Faktor Sensor disconnected
				default: f=0;
				
			}
	
			if(((d>>15)&1) != 0) f=-f;			// Negative Temp
		
		}
		else
		{
			// Der Widerstandswert soll gelesen werden
			d = DapiReadWord(handle, 0x4000 + ch*8 + 6);				// Widerstandswert lesen
	
			f = ((float) (d&0x7fff)) / 100;								// Faktor 100
			if(((d>>15)&1) != 0) f=-f;									// Negative
		}
	
		return f;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiCnt48ModeSet(long handle, long ch, long mode)
	{
		DapiWriteWord(handle, 0x5000 + ch*8 + 6, mode);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiCnt48ModeGet(long handle, long ch)
	{	
		return DapiReadWord(handle, 0x5000 + ch*8 + 6);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiCnt48CounterGet32(long handle, long ch)
	{
		return DapiReadLong(handle, 0x5000 + ch*8);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiPulseGenSet(long handle, long ch, long mode, long par0, long par1, long par2)
	{
	
		DapiWriteLong(handle, 0x5800 + ch*16 + 0 , mode);
		DapiWriteLong(handle, 0x5800 + ch*16 + 4 , par0);
		DapiWriteLong(handle, 0x5800 + ch*16 + 8 , par1);
		DapiWriteLong(handle, 0x5800 + ch*16 + 12, par2);
	
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiPWMOutSet(long handle, long ch, float data)
	{
		DapiWriteByte(handle, 0x0800 + ch  , (long) data);
	
	}
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiSpecialCommand(long handle, long cmd, long par1, long par2, long par3)
	{
		long ret=0;
		long cnt;
	
		switch((int) cmd)
		{
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_DA:
				switch((int) par1)
				{
					// ----------------------------------------
					case (int) DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT:
						DapiWriteByte(handle, 0x2000 + par2*8 + 7, 0x12);		// Auslieferungszustand laden
	
						cnt=100;
						do
						{
							--cnt;
						} while((DapiReadByte(handle, 0x2000 + par2*8 + 7) != 0xff) && (cnt!=0));
	
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG:
						DapiWriteByte(handle, 0x2000 + par2*8 + 7, 0x10);		// Ins EEPROM schreiben
	
						cnt=100;
						do
						{
							--cnt;
						} while((DapiReadByte(handle, 0x2000 + par2*8 + 7) != 0xff) && (cnt!=0));
	
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG:
						DapiWriteByte(handle, 0x2000 + par2*8 + 7, 0x11);		// Aus EEPROM laden
	
						cnt=100;
						do
						{
							--cnt;
						} while((DapiReadByte(handle, 0x2000 + par2*8 + 7) != 0xff) && (cnt!=0));
	
						break;
					// ----------------------------------------
				}
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_AD:
				switch((int) par1)
				{
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_READ_MULTIPLE_AD:
						if(par2>64) return -1;
						if(par3>64) return -1;
						if(par2>par3) return -1;
						

						byte[] temp_ad_buffer = new byte[((int)par3-(int)par2 + 1)*4];
						ret=DapiReadMultipleBytes(handle, 0x1000 + par2*4, (par3-par2+1)*4, 1, temp_ad_buffer, temp_ad_buffer.length);
						System.arraycopy(temp_ad_buffer, 0, global_ad_buffer, ((int)par2*4), temp_ad_buffer.length);
						
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_DEACTIVATE:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_disable | (0<<8));
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_ACTIVATE:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_disable | (1<<8));
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_INIT:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_init | (0<<8));
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_set_intervalL | ((par3&255)           <<8));
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_set_intervalH | ((par3>>8) & 255)     <<8);
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_SET_CHANNEL:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_chL | ((par3&255)          <<8));
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_chH | ((par3>>8) & 255)    <<8);
						break;
					// ----------------------------------------
				}
				break;

			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
	
	
						
						
			// ------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_SET_DIR_DX_8:
				DapiWriteLong(handle, 0x100 + par1/64, par2);
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_SET_DIR_DX_1:
				DapiWriteLong(handle, 0x120 + par1/8, par2);
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_GET_MODULE_CONFIG:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO:
					ret = DapiReadByte(handle, 0xff00);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI:
					ret = DapiReadByte(handle, 0xff02);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF:
					ret = DapiReadByte(handle, 0xff0c);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER:
					ret = DapiReadByte(handle, 0xff0e);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX:
					ret = DapiReadByte(handle, 0xff04);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD:
					ret = DapiReadByte(handle, 0xff08);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA:
					ret = DapiReadByte(handle, 0xff06);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER:
					ret = DapiReadByte(handle, 0xff0a);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP:
					ret = DapiReadByte(handle, 0xff10);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48:
					ret = DapiReadByte(handle, 0xff12);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN:
					ret = DapiReadByte(handle, 0xff14);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT:
					ret = DapiReadByte(handle, 0xff16);
					break;
	
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_GET_MODULE_VERSION:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0:
					ret = DapiReadByte(handle, 0xfff4) - '0';
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1:
					ret = DapiReadByte(handle, 0xfff5) - '0';
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2:
					ret = DapiReadByte(handle, 0xfff6) - '0';
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3:
					ret = DapiReadByte(handle, 0xfff7) - '0';
					break;
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_TIMEOUT:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC:
					DapiWriteWord(handle, 0xfd02, par2*10+ (par3%10));
					break;
	
				case (int) DAPI_SPECIAL_TIMEOUT_ACTIVATE:
					DapiWriteByte(handle, 0xfd00,1);
					break;
	
				case (int) DAPI_SPECIAL_TIMEOUT_DEACTIVATE:
					DapiWriteByte(handle, 0xfd00,0);
					break;
	
				case (int) DAPI_SPECIAL_TIMEOUT_GET_STATUS:
					ret = DapiReadByte(handle, 0xfd01);
					break;
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_DI:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET:
					DapiWriteByte(handle, 0xfd10, par2);
					break;
				case (int) DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET:
					ret = DapiReadByte(handle, 0xfd10);
					break;
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_WATCHDOG:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC:
					DapiWriteLong(handle, 0xe004, par2);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC:
					ret = DapiReadLong(handle, 0xe004);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_STATUS:
					ret=DapiReadByte(handle, 0xe000);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC:
					ret = DapiReadLong(handle, 0xe008);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC:
					ret = DapiReadLong(handle, 0xe00c);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC:
					DapiWriteLong(handle, 0xe008, par2);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC:
					DapiWriteLong(handle, 0xe00c, par2);
					break;
	
				
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_COUNTER:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_COUNTER_LATCH_ALL:
					DapiWriteByte(handle, 0xfe12, 0x19);					// Latch all Counter
					break;
				case (int) DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET:
					DapiWriteByte(handle, 0xfe12, 0x1a);					// Latch all Counter WITH RESET
					break;
				}
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_CNT48:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_CNT48_RESET_SINGLE:
					DapiWriteByte(handle, 0x5000 + par2*8, 0x00);			// Reset Counter Nr. "par2"
					break;
				case (int) DAPI_SPECIAL_CNT48_RESET_GROUP8:
					DapiWriteByte(handle, 0x5003 + (par2/8)*0x40, 0x00);	// Reset Counter Group Nr. "par2"
					break;
				case (int) DAPI_SPECIAL_CNT48_LATCH_GROUP8:
					DapiWriteByte(handle, 0x5002 + (par2/8)*0x40, 0x00);	// Latch Counter Group Nr. "par2"
					break;
				case (int) DAPI_SPECIAL_CNT48_DI_GET1:
					ret = DapiReadByte(handle, 0x5007 + (par2*8)) & 1;			// Bit 0 Latch Counter Group Nr. "par2"
	
					break;
				}
				break;
				
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_SOFTWARE_FIFO:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE:
					DapiWriteByte(handle, 0xfe30, 0x01);					// activate software fifo
					break;
				case (int) DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE:
					DapiWriteByte(handle, 0xfe30, 0x00);					// deactivate software fifo
					break;	
				case (int) DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS:
					ret = DapiReadByte(handle, 0xfe30) & 1;					// read software-fifo status (activated / deactivated)
					break;
				}
				break;			
		}
		
		return ret;
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiStepperCommand(long handle, long motor, long cmd, long par1, long par2, long par3, long par4)
	{
		long ret;
		long adr_base = (0x3000 | (motor*0x40));
		ret=0;
		byte[] buff = new byte[20];
		int pos;
	
		pos = 0;
	
		
		buff[pos++] = (byte) ((par3)     & 0xff);
		buff[pos++] = (byte) ((par3>>8)  & 0xff);
		buff[pos++] = (byte) ((par3>>16) & 0xff);
		buff[pos++] = (byte) ((par3>>24) & 0xff);
	
		buff[pos++] = (byte) ((par2)     & 0xff);
		buff[pos++] = (byte) ((par2>>8)  & 0xff);
		buff[pos++] = (byte) ((par2>>16) & 0xff);
		buff[pos++] = (byte) ((par2>>24) & 0xff);
	
		buff[pos++] = (byte) ((par1)     & 0xff);
		buff[pos++] = (byte) ((par1>>8)  & 0xff);
		buff[pos++] = (byte) ((par1>>16) & 0xff);
		buff[pos++] = (byte) ((par1>>24) & 0xff);
	
		buff[pos++] = (byte) ((cmd)     & 0xff);
		buff[pos++] = (byte) ((cmd>>8)  & 0xff);
		buff[pos++] = (byte) ((cmd>>16) & 0xff);
		buff[pos++] = (byte) ((cmd>>24) & 0xff);
		
		
		DapiWriteMultipleBytes(handle, adr_base + 0x10 , pos, 1, buff , pos);
	
	
		if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_0_BYTES)
		{
			ret=0;
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_1_BYTES)
		{
			ret=DapiReadByte(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_2_BYTES)
		{
			ret=DapiReadWord(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_4_BYTES)
		{
			ret=DapiReadLong(handle, (adr_base | 0x20));
		}
		
		
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------

	public long DapiStepperCommandEx(long handle, long motor, long cmd, long par1, long par2, long par3, long par4, long par5, long par6, long par7)
	{
		long ret;
		long adr_base = 0x3000 | motor*0x40;
		ret=0;
	
	
	
		byte[] buff = new byte[40];
		int pos;
	
		pos = 0;
	
		buff[pos++] = (byte) ((par7)     & 0xff);
		buff[pos++] = (byte) ((par7>>8)  & 0xff);
		buff[pos++] = (byte) ((par7>>16) & 0xff);
		buff[pos++] = (byte) ((par7>>24) & 0xff);
	
		buff[pos++] = (byte) ((par6)     & 0xff);
		buff[pos++] = (byte) ((par6>>8)  & 0xff);
		buff[pos++] = (byte) ((par6>>16) & 0xff);
		buff[pos++] = (byte) ((par6>>24) & 0xff);
	
		buff[pos++] = (byte) ((par5)     & 0xff);
		buff[pos++] = (byte) ((par5>>8)  & 0xff);
		buff[pos++] = (byte) ((par5>>16) & 0xff);
		buff[pos++] = (byte) ((par5>>24) & 0xff);
	
		buff[pos++] = (byte) ((par4)     & 0xff);
		buff[pos++] = (byte) ((par4>>8)  & 0xff);
		buff[pos++] = (byte) ((par4>>16) & 0xff);
		buff[pos++] = (byte) ((par4>>24) & 0xff);
	
		buff[pos++] = (byte) ((par3)     & 0xff);
		buff[pos++] = (byte) ((par3>>8)  & 0xff);
		buff[pos++] = (byte) ((par3>>16) & 0xff);
		buff[pos++] = (byte) ((par3>>24) & 0xff);
	
		buff[pos++] = (byte) ((par2)     & 0xff);
		buff[pos++] = (byte) ((par2>>8)  & 0xff);
		buff[pos++] = (byte) ((par2>>16) & 0xff);
		buff[pos++] = (byte) ((par2>>24) & 0xff);
	
		buff[pos++] = (byte) ((par1)     & 0xff);
		buff[pos++] = (byte) ((par1>>8)  & 0xff);
		buff[pos++] = (byte) ((par1>>16) & 0xff);
		buff[pos++] = (byte) ((par1>>24) & 0xff);
	
		buff[pos++] = (byte) ((cmd)     & 0xff);
		buff[pos++] = (byte) ((cmd>>8)  & 0xff);
		buff[pos++] = (byte) ((cmd>>16) & 0xff);
		buff[pos++] = (byte) ((cmd>>24) & 0xff);
	
		DapiWriteMultipleBytes(handle, adr_base + 0x00 , pos, 1, buff , pos);
	
		if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_0_BYTES)
		{
			ret=0;
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_1_BYTES)
		{
			ret=DapiReadByte(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_2_BYTES)
		{
			ret=DapiReadWord(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_4_BYTES)
		{
			ret=DapiReadLong(handle, (adr_base | 0x20));
		}
		
	
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiStepperGetStatus(long handle, long motor, long cmd)
	{
		long ret;
		long adr_base = 0x3000 | motor*0x40;
		ret=0;

		if (cmd == DAPI_STEPPER_STATUS_GET_POSITION)
		{
			ret = DapiReadLong(handle, (adr_base | 0x28));
		}
		else if (cmd == DAPI_STEPPER_STATUS_GET_SWITCH)
		{
			ret = DapiReadByte(handle, (adr_base | 0x2f));
		}
		else if (cmd == DAPI_STEPPER_STATUS_GET_ACTIVITY)
		{
			ret = DapiReadByte(handle, (adr_base | 0x2e));
		}
		
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWatchdogEnable(long handle)
	{
		DapiWriteByte(handle, 0xe000, 0x23);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWatchdogDisable(long handle)
	{
		DapiWriteByte(handle, 0xe000, 0x12);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWatchdogRetrigger(long handle)
	{
		DapiWriteByte(handle, 0xe001, 0x34);
	}
	
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWriteByte(long handle, long address, long value) 
	{
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// socket
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'W';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'B';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[tx_pos++] = (byte) (value & 0xff);				// DATA_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWriteWord(long handle, long address, long value) {
		
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'W';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'W';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[tx_pos++] = (byte) ((value >> 8) & 0xff);			// DATA_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((value >> 0) & 0xff);			// DATA_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWriteLong(long handle, long address, long value) 
	{		
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'W';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'L';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[tx_pos++] = (byte) ((value >> 24) & 0xff);		// DATA_BIT_24_31
		tx_buffer[tx_pos++] = (byte) ((value >> 16) & 0xff);		// DATA_BIT_16_23
		tx_buffer[tx_pos++] = (byte) ((value >> 8 ) & 0xff);		// DATA_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((value >> 0 ) & 0xff);		// DATA_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) {
			job_id = 0;
		}	
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
		}
		
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadByte(long handle, long address) 
	{
		int tx_pos = 0;
		int rx_pos = 7;
		long data;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'R';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'B';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
	
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
			
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 0;
		}
		
		// calculate data
		data = ((rx_buffer[rx_pos++] << 0 ) & 0xffL);
		
		return data;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadWord(long handle, long address) 
	{
		int tx_pos = 0;
		int rx_pos = 7;
		long data;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'R';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'W';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
		
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 0;
		}
		
		// calculate data
		data = 	((rx_buffer[rx_pos++] << 0 ) & 0xffL);
		data += ((rx_buffer[rx_pos++] << 8 ) & 0xff00L);
		
		return data;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadLong(long handle, long address) 
	{
		int tx_pos = 0;
		int rx_pos = 7;
		long data;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'R';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'L';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				// LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				// LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 0;
		}
		
		// calculate data
		data = 	((rx_buffer[rx_pos++] << 0 ) & 0xffL);
		data += ((rx_buffer[rx_pos++] << 8 ) & 0xff00L);
		data += ((rx_buffer[rx_pos++] << 16) & 0xff0000L);
		data += ((rx_buffer[rx_pos++] << 24) & 0xff000000L);

		return data;
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadMultipleBytes(long handle, long address, long address_depth, long increment, byte[] buff, long buff_len)
	{
		long i;
		long j;
		
		int pos = 0;
		int tx_pos = 0;
		int tx_cnt;
		
		long m_start_id;
		long m_data_id;
		long m_data_pos;
		
		// tx_buffer zusammenbauen
		tx_cnt=0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
	
		tx_buffer[tx_pos++]='R';									// COMMAND
		tx_buffer[tx_pos++]='M';									// WIDTH
	
		// address (2byte)
		tx_buffer[tx_pos++]= (byte) ((address >> 8 ) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address >> 0 ) & 0xff);		// ADDRESS_BIT_0_7
		
		// address_depth (2byte)
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 8 ) & 0xff);	// ADDRESS_DEPTH_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 0 ) & 0xff);	// ADDRESS_DEPTH_BIT_0_7
		
		// increment (2byte)
		tx_buffer[tx_pos++]= (byte) ((increment >> 8 ) & 0xff);		// INCREMENT_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((increment >> 0 ) & 0xff);		// INCREMENT_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				// LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				// LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}
		
		try 
		{
			output_stream.write(tx_buffer, 0, tx_pos);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 1;
		}
	
		// data_temp �berpr�fen
		// datenblock = start_id_multiple_byte(1) +  data_id(2) + addr_depth	
	
		for (i=0; i<increment; i++)
		{
			pos = 0;
			m_data_pos = i*(address_depth+3);
			
			// start_id + data_id aus dem buffer filtern
			m_start_id = rx_buffer[(int) (7 + (m_data_pos + (pos++)))];
			m_data_id = rx_buffer[(int) (7 + (m_data_pos + (pos++)))];
			m_data_id = (m_data_id << 8) | rx_buffer[(int) (7 + (m_data_pos + (pos++)))];
			
			// start_id checken
			if (m_start_id != DEDITEC_TCP_START_ID_FOR_MULTIPLE_BYTE_DATA)
			{
				return 1;			// Error
			}
			
			// data_id checken
			if (m_data_id != i)
			{
				return 1;			// Error
			}
			
		}
		
		// daten sind ok - daten in "richtigen buffer" schreiben
		tx_cnt = 0;
		
		for (i=0; i< increment; i++)
		{
			for (j=0; j<address_depth; j++)
			{
				buff[tx_cnt++] = rx_buffer[(int) (7 + 3 + j + i*(address_depth+3))];
			}
		}
	
		return 0;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiWriteMultipleBytes(long handle, long address, long address_depth, long increment, byte[] buff, long buff_len)
	{
		long i;
		long j;
		
		int pos = 0;
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1

		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID

		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++]='W';									// COMMAND //Write
		tx_buffer[tx_pos++]='M';									// WIDTH //Multiple

		// address (2byte)
		tx_buffer[tx_pos++]= (byte) ((address >> 8 ) & 0xff);	// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address >> 0 ) & 0xff);	// ADDRESS_BIT_0_7
		
		// address_depth (2byte)
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 8 ) & 0xff);	// ADDRESS_DEPTH_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 0 ) & 0xff);	// ADDRESS_DEPTH_BIT_0_7
		
		// increment (2byte)
		tx_buffer[tx_pos++]= (byte) ((increment >> 8 ) & 0xff);	// INCREMENT_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((increment >> 0 ) & 0xff);	// INCREMENT_BIT_0_7
		
		// data start
		for (i=0; i<increment; i++)
		{
			// START_ID_MULTIPLE_BYTE (1byte)
			tx_buffer[tx_pos++]= (byte) DEDITEC_TCP_START_ID_FOR_MULTIPLE_BYTE_DATA;		// START_ID_MULTIPLE_BYTE
			
			// DATA_ID (2byte)
			tx_buffer[tx_pos++]= (byte) ((i >> 8 ) & 0xff);			// DATA_ID_BIT_8_15
			tx_buffer[tx_pos++]= (byte) ((i >> 0 ) & 0xff);			// DATA_ID_BIT_0_7
			
			// data	
			for (j=0; j<address_depth; j++)
			{
				tx_buffer[tx_pos++] = buff[pos++];
			}
		}
		// data end
		
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();			
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 1;
		}
		
		return 0;
	
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void CheckIsValidDeditecAnswer()
	{
		int recv_pos = 0;
		
		// PACKET_ID_0 checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_PACKET_ID_0)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
		
		// PACKET_ID_1 checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_PACKET_ID_1)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
		
		// TCP_ANSWER_RO_1 checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_TCP_ANSWER_RO_1)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
		
		// TCP_ANSWER_OK checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_TCP_ANSWER_OK)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void SetError(long errorCode)
	{
		dapi_last_error = errorCode;
		
		switch ((int)errorCode)
		{
			case (int) DAPI_ERR_DEVICE_NOT_FOUND:
				dapi_last_error_text = "Device not found!";
				break;
				
			default:
				break;
		}
	}

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public boolean IsError()
	{
		if (dapi_last_error != DAPI_ERR_NONE)
		{
			System.out.printf("Error - Error Code = 0x%x\nMessage = %s\n", dapi_last_error,dapi_last_error_text);
		
			// clear last error
			dapi_last_error = DAPI_ERR_NONE;
			
			return true;
		}
		
		return false;
	}

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
}
	

- DelibErrorCodes.java
  Inhalt:
package DelibJava;

//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//
//
//
//  DelibErrorCodes.java
//  project: DELIB
//
//
//  (c) DEDITEC GmbH, 2009-2016
//  web: http://www.deditec.de/
//  mail: vertrieb@deditec.de
//
//
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************

public class DelibErrorCodes
{
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0000        
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_NONE                                       = 0;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0100        Allgemeine Error Codes
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_GEN_CLASS                                  = 0x0100;
    //
    public static final int DAPI_ERR_GEN_MALLOC_ERROR                           = 0x0101;
    public static final int DAPI_ERR_GEN_BUFFER_TOO_SMALL_ERROR                 = 0x0102;
    public static final int DAPI_ERR_GEN_ERROR_WITH_TEXT                        = 0x0103;
    //
    public static final int DAPI_ERR_GEN_SOCKET_ERROR                           = 0x0110;
    public static final int DAPI_ERR_GEN_BINDING_ERROR                          = 0x0111;
    public static final int DAPI_ERR_GEN_SIG_HANDLER_ERROR                      = 0x0112;
    //
    public static final int DAPI_ERR_GEN_UNKNOWN_ENCRYPTION_TYPE                = 0x0120;
    public static final int DAPI_ERR_GEN_ENCRYPTION_ERROR                       = 0x0121;
    //
    public static final int DAPI_ERR_GEN_ILLEGAL_MODULE_ID                      = 0x0130;
    public static final int DAPI_ERR_GEN_ILLEGAL_MODULE_NR                      = 0x0131;
    public static final int DAPI_ERR_GEN_ILLEGAL_HANDLE                         = 0x0132;
    //
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_MODE                     = 0x0140;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_IO_TYPE                  = 0x0141;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_CHANNEL                  = 0x0142;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_SW_FEATURE               = 0x0143;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_FUNCTION                 = 0x0144;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0200    Communication Errors
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_COM_CLASS                                  = 0x0200;
    //
    public static final int DAPI_ERR_COM_CONN_COULD_NOT_BE_ESTABLISHED          = 0x0201;
    public static final int DAPI_ERR_COM_DEVICE_DID_NOT_ANSWER                  = 0x0202;
    //
    public static final int DAPI_ERR_COM_HANDLE_INVALID                         = 0x0210;
    public static final int DAPI_ERR_COM_DELIB_ID_INVALID                       = 0x0211;
    public static final int DAPI_ERR_COM_FT_HANDLE_INVALID                      = 0x0212;
    public static final int DAPI_ERR_COM_FT_ERROR                               = 0x0213;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0300    Device Errors
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_DEV_CLASS                                  = 0x0300;
    //
    public static final int DAPI_ERR_DEV_PKT_CMD_ILLEGAL                        = 0x0301;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_ILLEGAL_COMMAND     1
    public static final int DAPI_ERR_DEV_PKT_DATA_LENGTH_ERROR                  = 0x0302;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_WRONG_DATA_LENGTH   2
    public static final int DAPI_ERR_DEV_PKT_DATA_CHECKSUM_ERROR                = 0x0303;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_WRONG_CHECKSUM      3
    public static final int DAPI_ERR_DEV_PKT_ADDR_NOT_FOR_ME                    = 0x0304;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_NOT_FOR_ME          4
    public static final int DAPI_ERR_DEV_PKT_OTHER_ERROR                        = 0x0305;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_NOT_FOR_ME          4
    //
    public static final int DAPI_ERR_DEV_PACKET_CMD_NOT_SUPPORTED               = 0x0310;       // BC-CMD or TCP-CMD
    public static final int DAPI_ERR_DEV_PACKET_ID_1_NOT_ALLOWED                = 0x0311;       // TCP
    public static final int DAPI_ERR_DEV_PACKET_ID_1_NOT_SUPPORTED              = 0x0312;       // TCP
    public static final int DAPI_ERR_DEV_PACKET_HEADER_NOT_OK                   = 0x0313;       // TCP
    public static final int DAPI_ERR_DEV_PACKET_SUBCMD_NOT_SUPPORTED            = 0x0314;       // TCP
    //
    public static final int DAPI_ERR_DEV_IO_ADDR_ILLEGAL                        = 0x0331;       // dev_io
    public static final int DAPI_ERR_DEV_IO_RD_WR_ERROR                         = 0x0332;       // dev_io
    public static final int DAPI_ERR_DEV_IO_SUB_ADDR_ILLEGAL                    = 0x0333;       // dev_io
    public static final int DAPI_ERR_DEV_IO_OTHER_ERROR                         = 0x0337;       // dev_io (7. von 7 mglichen Errors)
    public static final int DAPI_ERR_DEV_IO_HTML_ACCESS_DENIED                  = 0x0338;
    //
    public static final int DAPI_ERR_DEV_FS_INTERNAL_TEXT_BUFFER_TOO_SMALL      = 0x0345;
    public static final int DAPI_ERR_DEV_FS_RW_OFFSET_OUT_OF_SCOPE              = 0x0346;
    public static final int DAPI_ERR_DEV_FS_RW_LENGTH_OUT_OF_SCOPE              = 0x0347;
    public static final int DAPI_ERR_DEV_FS_BUFFER_TOO_SMALL                    = 0x0349;
    //
    public static final int DAPI_ERR_DEV_FILE_WRITE_ERROR                       = 0x0370;
    //
    public static final int DAPI_ERR_DEV_CONFIG_WRITE_PROTECTED                 = 0x0380;
    public static final int DAPI_ERR_DEV_CONFIG_KEY_NOT_PRESSED                 = 0x0381;
    public static final int DAPI_ERR_DEV_CONFIG_READ_ERROR                      = 0x0382;
    public static final int DAPI_ERR_DEV_CONFIG_WRITE_ERROR                     = 0x0383;
    public static final int DAPI_ERR_DEV_CONFIG_UPDATE_ERROR                    = 0x0384;       // Broadcast
    public static final int DAPI_ERR_DEV_CONFIG_PARAM_ONLY_ONE_TIME_WRITEABLE   = 0x0385;       // ETH
    public static final int DAPI_ERR_DEV_CONFIG_PARAM_IS_READ_ONLY              = 0x0386;
    public static final int DAPI_ERR_DEV_CONFIG_PARAM_IS_WRITE_ONLY             = 0x0387;
    public static final int DAPI_ERR_DEV_CONFIG_WRITE_PROTECTED_SW              = 0x0388;
    public static final int DAPI_ERR_DEV_CONFIG_FS_INVALID                      = 0x0389;
    public static final int DAPI_ERR_DEV_CONFIG_FS_DIR_NOT_FOUND                = 0x038a;
    public static final int DAPI_ERR_DEV_CONFIG_FS_DIR_ALREADY_EXIST            = 0x038b;
    public static final int DAPI_ERR_DEV_CONFIG_FS_IS_FULL                      = 0x038c;
    public static final int DAPI_ERR_DEV_CONFIG_FS_DIR_DATA_INVALID             = 0x038d;
    //
    public static final int DAPI_ERR_DEV_ENCRYPTED_HEADER_NOT_OK                = 0x0391;
    public static final int DAPI_ERR_DEV_ENCRYPTION_ERROR                       = 0x0392;       // Encryption
    public static final int DAPI_ERR_DEV_ENCRYPTION_TEMP_ADMIN_MODE_NOT_ALLOWED = 0x0393;
    public static final int DAPI_ERR_DEV_ENCRYPTION_NO_ADMIN_RIGHTS             = 0x0394;
    //
    public static final int DAPI_ERR_DEV_EXECUTE_CMD_ERROR                      = 0x03FF;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
}



[frontend]
- package.json
  Inhalt:
{
  "name": "motor-control-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "axios": "^1.3.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "^5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}



[frontend/public]
- index.html
  Inhalt:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motor Control</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>



[frontend/src]
- index.js
  Inhalt:
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


- index.css
  Inhalt:
body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  button {
    margin: 5px;
    padding: 10px 20px;
    cursor: pointer;
  }
  table {
    margin-bottom: 20px;
  }
  

- App.js
  Inhalt:
import React from 'react';
import MotorControl from './components/MotorControl';
import EmergencyStop from './components/EmergencyStop';
import StatusDisplay from './components/StatusDisplay';
import PinLayout from './components/PinLayout';

function App() {
  return (
    <div className="App">
      <h1>Motorsteuerung für dryve 16 D1</h1>
      <MotorControl />
      <EmergencyStop />
      <StatusDisplay />
      <PinLayout />
    </div>
  );
}

export default App;



[frontend/src/components]
- EmergencyStop.js
  Inhalt:
import React from 'react';
import axios from 'axios';

const EmergencyStop = () => {
  const handleEmergencyStop = async () => {
    try {
      const response = await axios.post('/api/motor/emergency-stop');
      console.log(response.data);
    } catch (error) {
      console.error('Fehler beim Not-Aus', error);
    }
  };

  return (
    <div>
      <h2>Not-Aus</h2>
      <button style={{ backgroundColor: 'red', color: 'white' }} onClick={handleEmergencyStop}>
        Not-Aus
      </button>
    </div>
  );
};

export default EmergencyStop;


- PinLayout.js
  Inhalt:
import React, { useState } from 'react';

const digitalInputsData = [
  { id: 1, binär: "Bit 0", tTeach: "Bit 0", takt: "Takt" },
  { id: 2, binär: "Bit 1", tTeach: "Bit 1", takt: "Richtung" },
  { id: 3, binär: "Bit 2", tTeach: "Bit 2", takt: "-" },
  { id: 4, binär: "Bit 3", tTeach: "Tippen links", takt: "-" },
  { id: 5, binär: "Bit 4", tTeach: "Tippen rechts", takt: "-" },
  { id: 6, binär: "Start", tTeach: "Start/Teach", takt: "-" },
  { id: 7, binär: "Freigabe", tTeach: "Freigabe", takt: "Freigabe" },
  { id: 8, binär: "Endlagenschalter positiv", tTeach: "Endlagenschalter positiv", takt: "Endlagenschalter positiv" },
  { id: 9, binär: "Endlagenschalter negativ", tTeach: "Endlagenschalter negativ", takt: "Endlagenschalter negativ" },
  { id: 10, binär: "Stopp/Reset", tTeach: "Stopp/Reset", takt: "Reset" }
];

const schrauberOutputsData = [
  { id: 1, label: "Programm Auswahl 1" },
  { id: 2, label: "Programm Auswahl 2" },
  { id: 3, label: "STOPMOTOR" },
  { id: 4, label: "START" },
  { id: 5, label: "IN ANG" },
  { id: 6, label: "IN RST" }
];

const PinLayout = () => {
  // Zustände für digitale Eingänge (10 Pins)
  const [digitalInputs, setDigitalInputs] = useState(Array(10).fill(false));
  // Zustände für Schrauber-Ausgänge (6 Pins)
  const [schrauberOutputs, setSchrauberOutputs] = useState(Array(6).fill(false));

  const toggleDigitalInput = (index) => {
    const newStates = [...digitalInputs];
    newStates[index] = !newStates[index];
    setDigitalInputs(newStates);
  };

  const toggleSchrauberOutput = (index) => {
    const newStates = [...schrauberOutputs];
    newStates[index] = !newStates[index];
    setSchrauberOutputs(newStates);
  };

  const toggleAll = () => {
    setDigitalInputs(digitalInputs.map(state => !state));
    setSchrauberOutputs(schrauberOutputs.map(state => !state));
  };

  const getIndicatorStyle = (state) => ({
    width: '20px',
    height: '20px',
    borderRadius: '50%',
    backgroundColor: state ? 'green' : 'red',
    display: 'inline-block',
    marginRight: '10px'
  });

  return (
    <div>
      <h2>Pin-Layout</h2>
      <h3>Dryve D1 Digitale Eingänge (X2)</h3>
      <table border="1" cellPadding="5">
        <thead>
          <tr>
            <th>Pin Nr.</th>
            <th>Binär</th>
            <th>Tipp/Teach</th>
            <th>Takt/Richtung</th>
            <th>Status</th>
            <th>Toggle</th>
          </tr>
        </thead>
        <tbody>
          {digitalInputsData.map((pin, index) => (
            <tr key={pin.id}>
              <td>{pin.id}</td>
              <td>{pin.binär}</td>
              <td>{pin.tTeach}</td>
              <td>{pin.takt}</td>
              <td>
                <span style={getIndicatorStyle(digitalInputs[index])}></span>
                {digitalInputs[index] ? 'An' : 'Aus'}
              </td>
              <td>
                <button onClick={() => toggleDigitalInput(index)}>Toggle</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      <h3>Schrauber Digitale Ausgänge</h3>
      <table border="1" cellPadding="5">
        <thead>
          <tr>
            <th>Output Nr.</th>
            <th>Bezeichnung</th>
            <th>Status</th>
            <th>Toggle</th>
          </tr>
        </thead>
        <tbody>
          {schrauberOutputsData.map((output, index) => (
            <tr key={output.id}>
              <td>{index + 10}</td>
              <td>{output.label}</td>
              <td>
                <span style={getIndicatorStyle(schrauberOutputs[index])}></span>
                {schrauberOutputs[index] ? 'An' : 'Aus'}
              </td>
              <td>
                <button onClick={() => toggleSchrauberOutput(index)}>Toggle</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      <button onClick={toggleAll} style={{ marginTop: '20px', padding: '10px 20px' }}>
        Test: Alle umschalten
      </button>
    </div>
  );
};

export default PinLayout;


- StatusDisplay.js
  Inhalt:
import React from 'react';
import axios from 'axios';

const EmergencyStop = () => {
  const handleEmergencyStop = async () => {
    try {
      const response = await axios.post('/api/motor/emergency-stop');
      console.log(response.data);
    } catch (error) {
      console.error('Fehler beim Not-Aus', error);
    }
  };

  return (
    <div>
      <h2>Not-Aus</h2>
      <button style={{ backgroundColor: 'red', color: 'white' }} onClick={handleEmergencyStop}>
        Not-Aus
      </button>
    </div>
  );
};

export default EmergencyStop;


- MotorControl.js
  Inhalt:
import React, { useState } from 'react';
import axios from 'axios';

const MotorControl = () => {
  const [profile, setProfile] = useState('');

  const startProfile = async (profileName) => {
    try {
      const response = await axios.post('/api/motor/start-profile', { profileName });
      console.log(response.data);
      // TODO: Hier deditec API integrieren, um den Controller anzusprechen.
    } catch (error) {
      console.error('Fehler beim Starten des Profils', error);
    }
  };

  const handleButtonClick = (profileName) => {
    setProfile(profileName);
    startProfile(profileName);
  };

  return (
    <div>
      <h2>Fahrprofile</h2>
      <button onClick={() => handleButtonClick('Profile1')}>Fahrprofil 1</button>
      <button onClick={() => handleButtonClick('Profile2')}>Fahrprofil 2</button>
    </div>
  );
};

export default MotorControl;



[backend]
- server.js
  Inhalt:
const express = require('express');
const bodyParser = require('body-parser');
const motorRoutes = require('./routes/motor');
const WebSocket = require('ws');
const http = require('http');

const app = express();
app.use(bodyParser.json());
app.use('/api/motor', motorRoutes);

// HTTP-Server erstellen
const server = http.createServer(app);

// WebSocket-Server für Echtzeit-Updates
const wss = new WebSocket.Server({ server });
wss.on('connection', ws => {
  console.log('Client via WebSocket verbunden');
  ws.on('message', message => {
    console.log(`Nachricht erhalten: ${message}`);
    // Weitere Verarbeitung falls erforderlich
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server läuft auf Port ${PORT}`);
});


- package.json
  Inhalt:
{
  "name": "motor-control-backend",
  "version": "1.0.0",
  "description": "Backend for dryve 16 D1 motor control",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.13.0",
    "body-parser": "^1.20.1"
  }
}



[backend/config]
- drivingProfiles.json
  Inhalt:
{
    "Profile1": {
      "speed": 100,
      "acceleration": 50,
      "positions": [0, 100, 200]
    },
    "Profile2": {
      "speed": 80,
      "acceleration": 40,
      "positions": [0, 80, 160]
    }
  }
  


[backend/utils]
- logger.js
  Inhalt:
const logger = {
    info: msg => console.log(`INFO: ${msg}`),
    error: msg => console.error(`ERROR: ${msg}`),
    warn: msg => console.warn(`WARN: ${msg}`)
  };
  
  module.exports = logger;
  


[backend/routes]
- motor.js
  Inhalt:
const express = require('express');
const router = express.Router();
const drivingProfiles = require('../config/drivingProfiles.json');
const logger = require('../utils/logger');

// Starten eines Fahrprofils
router.post('/start-profile', (req, res) => {
  const { profileName } = req.body;
  const profile = drivingProfiles[profileName];
  if (!profile) {
    logger.error(`Fahrprofil ${profileName} nicht gefunden`);
    return res.status(404).json({ error: 'Fahrprofil nicht gefunden' });
  }
  logger.info(`Fahrprofil ${profileName} wird gestartet`);
  // Logik zur Motorsteuerung (z.B. über deditec API) implementieren
  res.json({ status: 'Fahrprofil gestartet', profile });
});

// Manuelle Steuerung
router.post('/manual-control', (req, res) => {
  const { command } = req.body;
  logger.info(`Manuelle Steuerung: ${command}`);
  res.json({ status: 'Befehl ausgeführt', command });
});

// Not-Aus
router.post('/emergency-stop', (req, res) => {
  logger.warn('Not-Aus aktiviert');
  res.json({ status: 'Not-Aus aktiviert' });
});

module.exports = router;



