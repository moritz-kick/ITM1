[root]
- file_list.txt
  Inhalt:


- BSUSBExample.java
  Inhalt:
import DelibJava.DelibJNI;

public class BSUSBExample {
    public static void main(String[] args) {
        // 1) Modul öffnen (BS-USB mit 16 DI & 16 DO)
        long handle = DelibJNI.DapiOpenModule(DelibJNI.BS_USB_16, 0);
        if (handle == 0) {
            System.err.println("Modul konnte nicht geöffnet werden!");
            return;
        }
        System.out.println("BS-USB Modul geöffnet (Handle = " + handle + ").");

        // 2) Digitalen Ausgang 1 einschalten (auf HIGH setzen)
        DelibJNI.DapiDOSet1(handle, 1, 1);  // setzt Ausgang Kanal 1 auf 1 (AN)
        System.out.println("Ausgang 1 wurde auf AN gesetzt.");

        // 3) Digitalen Eingang 1 auslesen
        long value = DelibJNI.DapiDIGet1(handle, 1);
        System.out.println("Eingang 1 Zustand: " + (value == 1 ? "AN" : "AUS"));

        // 4) Modul schließen
        DelibJNI.DapiCloseModule(handle);
        System.out.println("BS-USB Modul geschlossen.");
    }
}


- script.py
  Inhalt:
import os


def list_files(directory, output_file):
    with open(output_file, "w", encoding="utf-8") as f:
        for root, dirs, files in os.walk(directory):
            if "node_modules" in root.split(os.sep) or ".git" in root.split(os.sep):
                continue

            rel_path = os.path.relpath(root, directory)
            f.write(f"[{rel_path if rel_path != '.' else 'root'}]\n")
            for file in files:
                if file in {
                    "package-lock.json",
                    "java_jni_digital_input",
                    ".gitignore",
                }:
                    continue
                file_path = os.path.join(root, file)
                try:
                    with open(
                        file_path, "r", encoding="utf-8", errors="ignore"
                    ) as file_content:
                        content = file_content.read()
                    f.write(f"- {file}\n")
                    f.write(f"  Inhalt:\n{content}\n\n")
                except Exception as e:
                    f.write(f"- {file} (Fehler beim Lesen: {e})\n")
            f.write("\n")


if __name__ == "__main__":
    current_directory = os.getcwd()  # Aktuelles Verzeichnis
    output_file = os.path.join(current_directory, "file_list.txt")
    list_files(current_directory, output_file)
    print(f"Dateiliste wurde in {output_file} gespeichert.")


- start_app.bat
  Inhalt:
@echo off
REM Starte Backend
start cmd /k "cd backend && npm start"

REM Starte Frontend
start cmd /k "cd frontend && npm start"

REM Warte 5 Sekunden, damit die Server hochfahren
timeout /t 5

REM Öffne das Frontend
start "" "chrome" "http://localhost:3000"

REM Öffne eine weitere Browser-Instanz mit der dryve D1 IP-Adresse
start "" "chrome" "http://169.254.104.33"



[DelibJava]
- DelibJNI64.java
  Inhalt:
package DelibJava;

//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//
//
//
//  DelibJNI64.java
//  project: DELIB
//
//
//  (c) DEDITEC GmbH, 2009-2016
//  web: http://www.deditec.de/
//  mail: vertrieb@deditec.de
//
//
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************

public class DelibJNI64
{
    static 
    {
        System.loadLibrary("DelibJNI64");
    }
    
    // all Module-ID's
    public static final int USB_Interface8                  = 1;            // USB-Controller8/USB-TTL-IN8-OUT8
    public static final int USB_CAN_STICK                   = 2;            // USB-CAN-Stick
    public static final int USB_LOGI_500                    = 3;            // USB-LOGI-500/USB-LOGI-250
    public static final int USB_SER_DEBUG                   = 4;            // USB-SER-DEBUG
    public static final int RO_SER                          = 5;            // RO-SER-Serie
    public static final int USB_BITP_200                    = 6;            // USB-BITP-200
    public static final int RO_USB1                         = 7;            // RO-USB-Serie
    public static final int RO_USB                          = 7;            // RO-USB-Serie
    public static final int RO_ETH                          = 8;            // RO-ETH-Serie
    public static final int USB_MINI_STICK                  = 9;            // USB-MINI-Stick-Serie
    public static final int USB_LOGI_18                     = 10;           // USB-LOGI-100
    public static final int RO_CAN                          = 11;           // RO-CAN-Serie
    public static final int USB_SPI_MON                     = 12;           // USB_SPI_MON
    public static final int USB_WATCHDOG                    = 13;           // USB_Watchdog
    public static final int USB_OPTOIN_8                    = 14;           // USB-OPTOIN8 / USB-RELAIS-8
    public static final int USB_RELAIS_8                    = 14;           // USB-OPTOIN8 / USB-RELAIS-8
    public static final int USB_OPTOIN_8_RELAIS_8           = 15;           // USB-OPTOIN-8-RELAIS-8
    public static final int USB_OPTOIN_16_RELAIS_16         = 16;           // USB-OPTOIN-16-RELAIS-16
    public static final int USB_OPTOIN_32                   = 16;           // USB-OPTOIN-16-RELAIS-16
    public static final int USB_RELAIS_32                   = 16;           // USB-OPTOIN-16-RELAIS-16
    public static final int USB_OPTOIN_32_RELAIS_32         = 17;           // USB-OPTOIN-32-RELAIS-32
    public static final int USB_OPTOIN_64                   = 17;           // USB-OPTOIN-32-RELAIS-32
    public static final int USB_RELAIS_64                   = 17;           // USB-OPTOIN-32-RELAIS-32

    public static final int BS_USB_8                        = 15;
    public static final int BS_USB_16                       = 16;
    public static final int BS_USB_32                       = 17;

    public static final int USB_TTL_32                      = 18;           // USB-TTL-32
    public static final int USB_TTL_64                      = 18;           // USB-TTL-64
    public static final int RO_ETH_INTERN                   = 19;

    public static final int BS_SER                          = 20;
    public static final int BS_CAN                          = 21;
    public static final int BS_ETH                          = 22;

    public static final int NET_ETH                         = 23;

    public static final int RO_CAN2                         = 24;           // RO-CPU2 / 480 MBit/sec - CAN VERSION
    public static final int RO_USB2                         = 25;           // RO-CPU2 / 480 MBit/sec - USB/SER Version
    public static final int RO_ETH_LC                       = 26;           // RO-ETH-LC

    public static final int ETH_RELAIS_8                    = 27;
    public static final int ETH_OPTOIN_8                    = 27;
    public static final int ETH_O4_R4_ADDA                  = 28;

    public static final int ETHERNET_MODULE                 = 29;

    public static final int ETH_TTL_64                      = 30;

    public static final int NET_USB2                        = 31;
    public static final int NET_ETH_LC                      = 32;
    public static final int NET_USB1                        = 33;
    public static final int NET_SER                         = 34;
    
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Declarations
    
    // ----------------------------------------------------------------------------
    // Special Function-Codes
    public static final int DAPI_SPECIAL_CMD_GET_MODULE_CONFIG                          = 1;
    public static final int DAPI_SPECIAL_CMD_TIMEOUT                                    = 2;
    public static final int DAPI_SPECIAL_CMD_DI                                         = 10;
    public static final int DAPI_SPECIAL_CMD_SET_DIR_DX_1                               = 3;
    public static final int DAPI_SPECIAL_CMD_SET_DIR_DX_8                               = 4;
    public static final int DAPI_SPECIAL_CMD_GET_MODULE_VERSION                         = 5;
    public static final int DAPI_SPECIAL_CMD_DA                                         = 6;
    public static final int DAPI_SPECIAL_CMD_WATCHDOG                                   = 7;
    public static final int DAPI_SPECIAL_CMD_COUNTER                                    = 8;
    public static final int DAPI_SPECIAL_CMD_AD                                         = 9;
    public static final int DAPI_SPECIAL_CMD_CNT48                                      = 11;
    public static final int DAPI_SPECIAL_CMD_SOFTWARE_FIFO                              = 12;
    public static final int DAPI_SPECIAL_CMD_MODULE_REBOOT                              = 13;
    public static final int DAPI_SPECIAL_CMD_MODULE_RESCAN                              = 14;
    public static final int DAPI_SPECIAL_CMD_RESTART_CHECK_MODULE_CONFIG                = 15;
    public static final int DAPI_SPECIAL_CMD_PWM                                        = 19;

    // values for PAR1
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI                       = 1;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF                    = 7;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER               = 8;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO                       = 2;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX                       = 3;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD                       = 4;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA                       = 5;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP                     = 9;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER                  = 6;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48                    = 10;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN                = 11;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT                  = 12;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_INTERFACE1            = 13;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_FEATURE1              = 14;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_GROUP                 = 15;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_CLASS                 = 16;
    public static final int DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_MODULE_ID                = 17;
    //
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0                       = 0;
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1                       = 1;
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2                       = 2;
    public static final int DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3                       = 3;
    //
    public static final int DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC                          = 1;
    public static final int DAPI_SPECIAL_TIMEOUT_ACTIVATE                               = 2;
    public static final int DAPI_SPECIAL_TIMEOUT_DEACTIVATE                             = 3;
    public static final int DAPI_SPECIAL_TIMEOUT_GET_STATUS                             = 4;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_LOAD_DEFAULT					= 5;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_CLR32					= 6;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_CLR32					= 7;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_SET32					= 8;
    public static final int DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_SET32					= 9;
    //
    public static final int DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET                         = 1;
    public static final int DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET                         = 2;
    //
    public static final int DAPI_SPECIAL_AD_READ_MULTIPLE_AD                            = 1;
    public static final int DAPI_SPECIAL_AD_FIFO_ACTIVATE                               = 2;
    public static final int DAPI_SPECIAL_AD_FIFO_DEACTIVATE                             = 3;
    public static final int DAPI_SPECIAL_AD_FIFO_GET_STATUS                             = 4;
    public static final int DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS                        = 5;
    public static final int DAPI_SPECIAL_AD_FIFO_SET_CHANNEL                            = 6;
    public static final int DAPI_SPECIAL_AD_FIFO_INIT                                   = 7;
    public static final int DAPI_SPECIAL_AD_FILTER_SET                                  = 8;
    //
    public static final int DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT                         = 1;
    public static final int DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG                   = 2;
    public static final int DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG                   = 3;
    //
    public static final int DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC                      = 1;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC                      = 2;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_STATUS                            = 3;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC                   = 4;
    public static final int DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC       = 5;
    public static final int DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC         = 6;
    public static final int DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC         = 7;
    //
    public static final int DAPI_SPECIAL_COUNTER_LATCH_ALL                              = 1;
    public static final int DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET                   = 2;
    //
    public static final int DAPI_SPECIAL_CNT48_RESET_SINGLE                             = 1;
    public static final int DAPI_SPECIAL_CNT48_RESET_GROUP8                             = 2;
    public static final int DAPI_SPECIAL_CNT48_LATCH_GROUP8                             = 3;
    public static final int DAPI_SPECIAL_CNT48_DI_GET1                                  = 4;
    //
    public static final int DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE                         = 1;
    public static final int DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE                       = 2;
    public static final int DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS                       = 3;
    //
    public static final int DAPI_SPECIAL_PWM_FREQ_LOAD_DFAULT                           = 1;
    public static final int DAPI_SPECIAL_PWM_FREQ_SAVE_EEPROM                           = 2;
    public static final int DAPI_SPECIAL_PWM_FREQ_LOAD_EEPROM                           = 3;
    public static final int DAPI_SPECIAL_PWM_FREQ_SET                                   = 4;

    // values for PAR2
    public static final int DAPI_SPECIAL_AD_CH0_CH15                                    = 0;
    public static final int DAPI_SPECIAL_AD_CH16_CH31                                   = 1;
    public static final int DAPI_SPECIAL_AD_CH32_CH47                                   = 2;
    public static final int DAPI_SPECIAL_AD_CH48_CH63                                   = 3;

    // ----------------------------------------------------------------------------
    // DapiScanModules-Codes
    public static final int DAPI_SCANMODULE_GET_MODULES_AVAILABLE                       = 1;

    // ----------------------------------------------------------------------------
    // SOFTWARE Features Class
    public static final int DAPI_SW_CLASS_TYPE_OF_MODULE_IDENTIFICATION                 = (1<<0);           // Bit 0
    public static final int DAPI_SW_CLASS_DI_DO_DX_CHANNELS                             = (1<<1);           // Bit 1
    public static final int DAPI_SW_CLASS_AD_DA_CHANNELS                                = (1<<2);           // Bit 2

    // ----------------------------------------------------------------------------
    // Hardware Group
    public static final int DAPI_HW_GROUP_RO                                            = (1<<0);           // Bit 0
    public static final int DAPI_HW_GROUP_LOGICANALYZER                                 = (1<<1);           // Bit 1
    public static final int DAPI_HW_GROUP_DI_DO_AD_DA                                   = (1<<2);           // Bit 2
    public static final int DAPI_HW_GROUP_USB                                           = (1<<3);           // Bit 3
    public static final int DAPI_HW_GROUP_BS                                            = (1<<4);           // Bit 4
    public static final int DAPI_HW_GROUP_NET                                           = (1<<5);           // Bit 5
    public static final int DAPI_HW_GROUP_ETH                                           = (1<<6);           // Bit 6

    // --------------------------------------------------------
    // Software Feature Bits
    public static final int DAPI_SW_FEATURE_BIT_SUPPORTED_BY_FIRMWARE                   = 0x00000001;
    public static final int DAPI_SW_FEATURE_BIT_SOFTWARE_FIFO                           = 0x00000002;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DO_CMD_SET_CLR_BIT_32               = 0x00000004;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_RN23                             = 0x00000008;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_E2_2K                            = 0x00000020;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_E2_32K                           = 0x00000040;
    public static final int DAPI_SW_FEATURE_BIT_EEPROM_FS_SUPPORT                       = 0x00000080;
    public static final int DAPI_SW_FEATURE_BIT_DX_1_MODE                               = 0x00000010;
    public static final int DAPI_SW_FEATURE_BIT_AUTO_OUTPUTS_OFF_TIMEOUT                = 0x02000000;
    public static final int DAPI_SW_FEATURE_BIT_AUTO_OUTPUTS_OFF_TIMEOUT_WITH_MASK		= 0x00008000;
    public static final int DAPI_SW_FEATURE_BIT_SUPP_INDIVIDUAL_CH_NAMES                = 0x00001000;
    public static final int DAPI_SW_FEATURE_BIT_DEV_IO_REG_ERR_SUPP                     = 0x00002000;
    public static final int DAPI_SW_FEATURE_BIT_SUPP_SYSTEM_INFO                        = 0x00004000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_WATCHDOG                            = 0x10000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DI                                  = 0x20000000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DI_CNT                              = 0x40000000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DI_CNT_LATCH                        = 0x00080000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DI_FF                               = 0x80000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DO                                  = 0x01000000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_DO_WITH_TIMER                       = 0x00040000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_PWM_OUT                             = 0x04000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DX                                  = 0x08000000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_DA                                  = 0x00100000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_AD                                  = 0x00200000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_CNT_OUT32                           = 0x00400000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_CNT_IN48                            = 0x00800000;

    public static final int DAPI_SW_FEATURE_BIT_CFG_TEMP                                = 0x00010000;
    public static final int DAPI_SW_FEATURE_BIT_CFG_STEPPER                             = 0x00020000;

    // --------------------------------------------------------
    // Hardware Interface Bits
    public static final int DAPI_HW_INTERFACE_BIT_SUPPORTED_BY_FIRMWARE                 = 0x00000001;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_ETH                               = 0x00000002;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_CAN                               = 0x00000004;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_RS232                             = 0x00000008;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_RS232_RS485                       = 0x00000010;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_USB1                              = 0x00000020;
    public static final int DAPI_HW_INTERFACE_BIT_CFG_USB2                              = 0x00000040;

    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_MASK                           = 0xFF000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_RO                             = 0x01000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_RO2                            = 0x02000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_BS                             = 0x03000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_NET                            = 0x04000000;
    public static final int DAPI_HW_INTERFACE_PRODUCT_ID_NET_IP                         = 0x05000000;

    // --------------------------------------------------------
    // TCP Feature Bits
    public static final int DAPI_TCP_FEATURE_BIT_SUPPORTED_BY_FIRMWARE                  = 0x00000001;
    public static final int DAPI_TCP_FEATURE_BIT_SUPP_RTC                               = 0x00000002;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Prototypes for DELIB-Functions
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------

    // ----------------------------------------------------------------------------
    // 
    public static native int DapiOpenModule(int moduleID, int nr);
    // left out (not possible): DapiOpenModuleEx
    public static native int DapiCloseModule(int handle);

    public static native int DapiScanModule(int moduleID, int cmd);
    public static native int DapiScanAllModulesAvailable(int todo);
    public static native int DapiScanAllModulesAvailableListEcecute(int nr, int todo);

    public static native int DapiGetDELIBVersion(int mode, int par);

    public static native int DapiPing(int handle, int value);

    // ----------------------------------------------------------------------------
    // Register Access
    public static native void DapiWriteByte(int handle, int adress, int value);
    public static native void DapiWriteWord(int handle, int adress, int value);
    public static native void DapiWriteLong(int handle, int adress, int value);
    public static native void DapiWriteLongLong(int handle, int adress, long value);

    public static native int DapiReadByte(int handle, int adress);
    public static native int DapiReadWord(int handle, int adress);
    public static native int DapiReadLong(int handle, int adress);
    public static native long DapiReadLongLong(int handle, int adress);

    // ----------------------------------------------------------------------------
    // Error Handling
    public static native int DapiGetLastError();
    // left out (not possible): DapiGetLastErrorText
    public static native void DapiClearLastError();

    // ----------------------------------------------------------------------------
    // Digital Inputs
    public static native int DapiDIGet1(int handle, int ch);
    public static native int DapiDIGet8(int handle, int ch);
    public static native int DapiDIGet16(int handle, int ch);
    public static native int DapiDIGet32(int handle, int ch);
    public static native long DapiDIGet64(int handle, int ch);  

    public static native int DapiDIGetFF32(int handle, int ch);

    public static native int DapiDIGetCounter(int handle, int ch, int mode);

    // ----------------------------------------------------------------------------
    // Digital Outputs
    public static native void DapiDOSet1(int handle, int ch, int data);
    public static native void DapiDOSet8(int handle, int ch, int data);
    public static native void DapiDOSet16(int handle, int ch, int data);
    public static native void DapiDOSet32(int handle, int ch, int data);
    public static native void DapiDOSet64(int handle, int ch, long data);

    public static native int DapiDOReadback32(int handle, int ch);
    public static native long DapiDOReadback64(int handle, int ch);

    public static native void DapiDOSet1_WithTimer(int handle, int ch, int data, int time_ms);
    public static native void DapiDOSetBit32(int handle, int ch, int data);
    public static native void DapiDOClrBit32(int handle, int ch, int data);

    // ----------------------------------------------------------------------------
    // Analog Inputs
    public static native int DapiADGet(int handle, int ch);
    // left out (not possible): DapiADGetValueModeUnit
    public static native float DapiADGetVolt(int handle, int ch);
    public static native float DapiADGetmA(int handle, int ch);
    public static native void DapiADSetMode(int handle, int ch, int mode);
    public static native int DapiADGetMode(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Analog Outputs
    public static native void DapiDASet(int handle, int ch, int data);
    public static native void DapiDASetVolt(int handle, int ch, float data);
    public static native void DapiDASetmA(int handle, int ch, float data);
    // left out (not possible): DapiDAGetValueModeUnit  
    public static native void DapiDASetMode(int handle, int ch, int mode);
    public static native int DapiDAGetMode(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Temperature Inputs
    public static native float DapiTempGet(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Counter48 Inputs
    public static native void DapiCnt48ModeSet(int handle, int ch, int mode);
    public static native int DapiCnt48ModeGet(int handle, int ch);
    public static native int DapiCnt48CounterGet32(int handle, int ch);
    public static native long DapiCnt48CounterGet48(int handle, int ch);

    // ----------------------------------------------------------------------------
    // Pulse-Generator Outputs
    public static native void DapiPulseGenSet(int handle, int ch, int mode, int par0, int par1, int par2);

    // ----------------------------------------------------------------------------
    // PWM Outputs
    public static native void DapiPWMOutSet(int handle, int ch, float data);
    
    // ----------------------------------------------------------------------------
    // Stepper
    public static native int DapiStepperCommand(int handle, int motor, int cmd, int par1, int par2, int par3, int par4);
    public static native int DapiStepperCommandEx(int handle, int motor, int cmd, int par1, int par2, int par3, int par4, int par5, int par6, int par7);
    public static native int DapiStepperGetStatus(int handle, int motor, int cmd);

    // ----------------------------------------------------------------------------
    // Watchdog
    public static native void DapiWatchdogEnable(int handle);
    public static native void DapiWatchdogDisable(int handle);
    public static native void DapiWatchdogRetrigger(int handle);

    // ----------------------------------------------------------------------------
    // Fifo
    // left out (not possible): DapiReadFifo

    // ----------------------------------------------------------------------------
    // CAN
    // left out (not possible): DAPI_CAN_MESSAGE_STRUCT
    // left out (not possible): DapiCANCommand
    // left out (not possible): DapiCANGetPacket
    // left out (not possible): DapiCANSendPacket

    // ----------------------------------------------------------------------------
    // Special
    public static native int DapiSpecialCommand(int handle, int cmd, int par1, int par2, int par3);
    // left out (not possible): DapiSpecialCommandExt

    // left out (not possible): DapiReadMultipleBytes
    // left out (not possible): DapiWriteMultipleBytes

    // ----------------------------------------------------------------------------
    // DI - Counter Mode
    public static final int DAPI_CNT_MODE_READ                              = 0x00;
    public static final int DAPI_CNT_MODE_READ_WITH_RESET                   = 0x01;
    public static final int DAPI_CNT_MODE_READ_LATCHED                      = 0x02;

    // ----------------------------------------------------------------------------
    // A/D and D/A Modes
    public static final int DAPI_ADDA_MODE_UNIPOL_10V                       = 0x00;
    public static final int DAPI_ADDA_MODE_UNIPOL_5V                        = 0x01;
    public static final int DAPI_ADDA_MODE_UNIPOL_2V5                       = 0x02;

    public static final int DAPI_ADDA_MODE_BIPOL_10V                        = 0x40;
    public static final int DAPI_ADDA_MODE_BIPOL_5V                         = 0x41;
    public static final int DAPI_ADDA_MODE_BIPOL_2V5                        = 0x42;

    public static final int DAPI_ADDA_MODE_0_20mA                           = 0x80;
    public static final int DAPI_ADDA_MODE_4_20mA                           = 0x81;
    public static final int DAPI_ADDA_MODE_0_24mA                           = 0x82;
    //public static final int DAPI_ADDA_MODE_0_25mA                         = 0x83;
    public static final int DAPI_ADDA_MODE_0_50mA                           = 0x84;

    public static final int DAPI_ADDA_MODE_BI_CAL_MODE                      = 0xfd;
    public static final int DAPI_ADDA_MODE_0_20mA_TESTMODE                  = 0xfe;
    public static final int DAPI_ADDA_MODE_BIPOL_10V_TESTMODE               = 0xff;

    public static final int DAPI_ADDA_MODE_DA_DISABLE                       = 0x100;
    public static final int DAPI_ADDA_MODE_DA_ENABLE                        = 0x200;

    public static final int DAPI_ADDA_MODE_PREVENT_DAPI_MODE_ERROR          = 0x8000;

    // --------------------------------------------------------
    // A/D and D/A units
    public static final int DAPI_ADDA_UNIT_ILLEGAL                          = 0x00;
    public static final int DAPI_ADDA_UNIT_VOLT                             = 0x01;
    public static final int DAPI_ADDA_UNIT_MA                               = 0x02;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Stepper-Defines

    // ------------------------------------
    // ERROR Codes
    public static final int DAPI_STEPPER_ERR_NONE                           = 0;                // es liegt kein Fehler vor 
    public static final int DAPI_STEPPER_ERR_PARAMETER                      = 1;                // Parameter hat falschen Wertebereich 
    public static final int DAPI_STEPPER_ERR_MOTOR_MOVE                     = 2;                // Kommando abgelehnt, da sich der Motor dreht
    public static final int DAPI_STEPPER_ERR_DISABLE_MOVE                   = 3;                // Kommando abgehelnt, da Motorbewegung disabled ist
    public static final int DAPI_STEPPER_ERR_DEVICE_NOT_FOUND               = -1;       // es liegt kein Fehler vor 

    // ------------------------------------
    // Special Stepper Function-Codes
    public static final int DAPI_STEPPER_RETURN_0_BYTES                     = 0x00000000;       // Kommando schickt 0 Byte als Antwort
    public static final int DAPI_STEPPER_RETURN_1_BYTES                     = 0x40000000;       // Kommando schickt 1 Byte als Antwort
    public static final int DAPI_STEPPER_RETURN_2_BYTES                     = 0x80000000;       // Kommando schickt 2 Byte als Antwort
    public static final int DAPI_STEPPER_RETURN_4_BYTES                     = 0xc0000000;       // Kommando schickt 4 Byte als Antwort

    public static final int DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC                = ( 0x00000001 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_GET_MOTORCHARACTERISTIC                = ( 0x00000002 + DAPI_STEPPER_RETURN_4_BYTES ); 
    public static final int DAPI_STEPPER_CMD_SET_POSITION                           = ( 0x00000003 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GO_POSITION                            = ( 0x00000004 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GET_POSITION                           = ( 0x00000005 + DAPI_STEPPER_RETURN_4_BYTES );  
    public static final int DAPI_STEPPER_CMD_SET_FREQUENCY                          = ( 0x00000006 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_SET_FREQUENCY_DIRECTLY                 = ( 0x00000007 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GET_FREQUENCY                          = ( 0x00000008 + DAPI_STEPPER_RETURN_2_BYTES );  
    public static final int DAPI_STEPPER_CMD_FULLSTOP                               = ( 0x00000009 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_STOP                                   = ( 0x00000010 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_GO_REFSWITCH                           = ( 0x00000011 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_DISABLE                                = ( 0x00000014 + DAPI_STEPPER_RETURN_0_BYTES );  
    public static final int DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_LOAD_DEFAULT       = ( 0x00000015 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_SAVE        = ( 0x00000016 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_LOAD        = ( 0x00000017 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_GET_CPU_TEMP                           = ( 0x00000018 + DAPI_STEPPER_RETURN_1_BYTES );
    public static final int DAPI_STEPPER_CMD_GET_MOTOR_SUPPLY_VOLTAGE               = ( 0x00000019 + DAPI_STEPPER_RETURN_2_BYTES );
    public static final int DAPI_STEPPER_CMD_GO_POSITION_RELATIVE                   = ( 0x00000020 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_EEPROM_ERASE                           = ( 0x00000021 + DAPI_STEPPER_RETURN_0_BYTES );
    public static final int DAPI_STEPPER_CMD_SET_VECTORMODE                         = ( 0x00000040 + DAPI_STEPPER_RETURN_0_BYTES );  

    // ------------------------------------
    // values for PAR1 for DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STEPMODE                             = 1;    // Schrittmode (Voll-, Halb-, Viertel-, Achtel-, Sechszehntelschritt 
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOFREQUENCY                          = 2;    // Schrittfrequenz bei GoPosition [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STARTFREQUENCY                       = 3;    // Startfrequenz [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STOPFREQUENCY                        = 4;    // Stopfrequenz [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_MAXFREQUENCY                         = 5;    // maximale Frequenz [Vollschritt / s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_ACCELERATIONSLOPE                    = 6;    // Beschleunigung in [Vollschritten / ms]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_DECELERATIONSLOPE                    = 7;    // Bremsung in [Vollschritten / ms]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_PHASECURRENT                         = 8;    // Phasenstrom [mA]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_HOLDPHASECURRENT                     = 9;    // Phasenstrom bei Motorstillstand [mA]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_HOLDTIME                             = 10;   // Zeit in der der Haltestrom fliet nach Motorstop [s]
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_STATUSLEDMODE                        = 11;   // Betriebsart der Status-LED
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW1                        = 12;   // invertiere Funktion des Endschalter1  
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW2                        = 13;   // invertiere Funktion des Endschalter12 
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW1                        = 14;   // invertiere Funktion des Referenzschalterschalter1
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW2                        = 15;   // invertiere Funktion des Referenzschalterschalter2
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_INVERT_DIRECTION                     = 16;   // invertiere alle Richtungsangaben
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_ENDSWITCH_STOPMODE                   = 17;   // Bei Endschalter soll (0=full stop/1=stop mit rampe)
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOENDSWITCH     = 18;   // Motor Frequency for GoReferenceCommand
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_AFTERENDSWITCH  = 19;   // Motor Frequency for GoReferenceCommand
    public static final int DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOOFFSET        = 20;   // Motor Frequency for GoReferenceCommand

    // ----------------------------------------------------------------------------
    // values for PAR1 for DAPI_STEPPER_CMD_GO_REFSWITCH
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF1                  = 1;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF2                  = 2;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_LEFT              = 4;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_RIGHT             = 8;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_POSITIVE       = 16;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_NEGATIVE       = 32;
    public static final int DAPI_STEPPER_GO_REFSWITCH_PAR_SET_POS_0             = 64;

    // ------------------------------------
    // Stepper Read Status
    public static final int DAPI_STEPPER_STATUS_GET_POSITION                    = 0x01;
    public static final int DAPI_STEPPER_STATUS_GET_SWITCH                      = 0x02;
    public static final int DAPI_STEPPER_STATUS_GET_ACTIVITY                    = 0x03;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // CAN-Defines

    // ------------------------------------
    // CAN Commands
    public static final int DAPI_CAN_CMD_SET_BITRATE            = 1;
    public static final int DAPI_CAN_CMD_SET_MASK0              = 2;
    public static final int DAPI_CAN_CMD_SET_RX_ADDRESS         = 3;
    public static final int DAPI_CAN_CMD_CLR_TIMESTAMP          = 4;
    public static final int DAPI_CAN_CMD_GET_BITRATE            = 5;
    public static final int DAPI_CAN_CMD_GET_TIMESTAMP          = 6;

    public static final int DAPI_CAN_CMD_TEST_GEN_RX_PACK       = 0xfffffff0;

    public static final int DAPI_PAR_CAN_MESSAGE_BOX_0          = 0;
    public static final int DAPI_PAR_CAN_MESSAGE_BOX_1          = 1;
    public static final int DAPI_PAR_CAN_MESSAGE_BOX_2          = 2;
    public static final int DAPI_PAR_CAN_MESSAGE_BOX_3          = 3;

    public static final int DAPI_CAN_BITRATE_10000              = 10000;
    public static final int DAPI_CAN_BITRATE_20000              = 20000;
    public static final int DAPI_CAN_BITRATE_50000              = 50000;
    public static final int DAPI_CAN_BITRATE_100000             = 100000;
    public static final int DAPI_CAN_BITRATE_125000             = 125000;
    public static final int DAPI_CAN_BITRATE_250000             = 250000;
    public static final int DAPI_CAN_BITRATE_500000             = 500000;
    public static final int DAPI_CAN_BITRATE_1000000            = 1000000;

    public static final int DAPI_CAN_MASK_SINGLE                = 0xffffffff;
    public static final int DAPI_CAN_MASK_ALL                   = 0x0;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // CNT48 Commands

    public static final int DAPI_CNT48_FILTER_20ns              = 0x0000;
    public static final int DAPI_CNT48_FILTER_100ns             = 0x1000;
    public static final int DAPI_CNT48_FILTER_250ns             = 0x2000;
    public static final int DAPI_CNT48_FILTER_500ns             = 0x3000;
    public static final int DAPI_CNT48_FILTER_1us               = 0x4000;
    public static final int DAPI_CNT48_FILTER_2_5us             = 0x5000;
    public static final int DAPI_CNT48_FILTER_5us               = 0x6000;
    public static final int DAPI_CNT48_FILTER_10us              = 0x7000;
    public static final int DAPI_CNT48_FILTER_25us              = 0x8000;
    public static final int DAPI_CNT48_FILTER_50us              = 0x9000;
    public static final int DAPI_CNT48_FILTER_100us             = 0xA000;
    public static final int DAPI_CNT48_FILTER_250us             = 0xB000;
    public static final int DAPI_CNT48_FILTER_500us             = 0xC000;
    public static final int DAPI_CNT48_FILTER_1ms               = 0xD000;
    public static final int DAPI_CNT48_FILTER_2_5ms             = 0xE000;
    public static final int DAPI_CNT48_FILTER_5ms               = 0xF000;

    public static final int DAPI_CNT48_MODE_COUNT_RISING_EDGE                   = 0x0000;
    public static final int DAPI_CNT48_MODE_COUNT_RISING_EDGE_X2                = 0x0001;
    public static final int DAPI_CNT48_MODE_COUNT_RISING_EDGE_X4                = 0x0002;
    public static final int DAPI_CNT48_MODE_T                                   = 0x000D;
    public static final int DAPI_CNT48_MODE_FREQUENCY                           = 0x000E;
    public static final int DAPI_CNT48_MODE_PWM                                 = 0x000F;

    public static final int DAPI_CNT48_SUBMODE_NO_RESET                         = 0x0000;
    public static final int DAPI_CNT48_SUBMODE_RESET_WITH_READ                  = 0x0010;
    public static final int DAPI_CNT48_SUBMODE_NO_RESET_NO_HW_RESET             = 0x0020;
    public static final int DAPI_CNT48_SUBMODE_RESET_WITH_READ_NO_HW_RESET      = 0x0030;
    public static final int DAPI_CNT48_SUBMODE_RESET_ON_CH_7                    = 0x0070;
    public static final int DAPI_CNT48_SUBMODE_LATCH_COMMON                     = 0x0080;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_1ms          = 0x0030;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_10ms         = 0x0020;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_100ms        = 0x0010;
    public static final int DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_1sec         = 0x0000;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Software FIFO Commands

    public static final int DAPI_FIFO_TYPE_READ_AD_FIFO                         = 0x01;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // PWM Commands

    public static final int DAPI_PWM_FREQUENCY_10HZ                             = 1;
    public static final int DAPI_PWM_FREQUENCY_100HZ                            = 10;
    public static final int DAPI_PWM_FREQUENCY_250HZ                            = 25;
    public static final int DAPI_PWM_FREQUENCY_1000HZ                           = 100;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Definitions for DapiOpenEx

    // left out (not possible): DAPI_OPENMODULEEX_STRUCT;

    public static final int DAPI_OPEN_MODULE_OPTION_USE_EXBUFFER                = (1<<0);   // Bit 0
    public static final int DAPI_OPEN_MODULE_OPTION_NO_RESCAN                   = (1<<1);   // Bit 1

    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_NONE               = 0;
    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_NORMAL             = 1;
    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_ADMIN              = 2;
    public static final int DAPI_OPEN_MODULE_ENCRYPTION_TYPE_ADMIN_TEMP         = 3;

    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
}



- Delib.java
  Inhalt:
package DelibJava;

//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//
//
//
//  Delib.java
//  project: DELIB
//
//
//  (c) DEDITEC GmbH, 2009-2016
//  web: http://www.deditec.de/
//  mail: vertrieb@deditec.de
//
//
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.net.InetSocketAddress;
import java.net.Socket;

public class Delib 
{
	// ----------------------------------------------------------------------------
	// Private global vars
	private int job_id = 0;
	private Socket socket;
	private InputStream input_stream;
	private OutputStream output_stream;
	private byte[] tx_buffer = new byte[256];
	private int amount_bytes_received;
	private byte[] rx_buffer = new byte[256];
	private byte[] global_ad_buffer = new byte[128*4];	// Max 128 chan
	private long dapi_last_error = 0;
	private String dapi_last_error_text;

	// ----------------------------------------------------------------------------	
	// Intern
	// ----------------------------------------------------------------------------	
	private static final long DEDITEC_TCP_START_ID_FOR_MULTIPLE_BYTE_DATA			= 35;
	// ----------------------------------------------------------------------------	
	private static final long DEDITEC_PACKET_ID_0									= 0x63;
	private static final long DEDITEC_PACKET_ID_1									= 0x9a;
	private static final long DEDITEC_TCP_ANSWER_RO_1								= 0x81;
	private static final long DEDITEC_TCP_ANSWER_OK									= 0;
	// ----------------------------------------------------------------------------	
	// RO-FIFO Commands
	private static final long RO_FIFO_CMD_fifo_init 								= 1;
	private static final long RO_FIFO_CMD_fifo_set_intervalL						= 2;
	private static final long RO_FIFO_CMD_fifo_set_intervalH						= 3;
	private static final long RO_FIFO_CMD_fifo_enable_chL							= 4;
	private static final long RO_FIFO_CMD_fifo_enable_chH							= 5;
	private static final long RO_FIFO_CMD_fifo_enable_disable						= 6;
	
	// ----------------------------------------------------------------------------
	// ERROR Codes
	public static final long DAPI_ERR_NONE											= 0;
	public static final long DAPI_ERR_DEVICE_NOT_FOUND								= -1;
	public static final long DAPI_ERR_COMMUNICATION_ERROR							= -2;
	public static final long DAPI_ERR_ILLEGAL_HANDLE								= -10;
	public static final long DAPI_ERR_FUNCTION_NOT_DEFINED							= -11;
	public static final long DAPI_ERR_ILLEGAL_COM_HANDLE							= -12;
	public static final long DAPI_ERR_ILLEGAL_MODE									= -13;
	public static final long DAPI_ERR_WITH_TEXT										= -14;
	public static final long DAPI_ERR_SW_FEATURE_NOT_SUPPORTED						= -15;
	public static final long DAPI_ERR_ILLEGAL_IO_TYPE								= -16;
	public static final long DAPI_ERR_ILLEGAL_CHANNEL								= -17;

	// ----------------------------------------------------------------------------
	// Special Function-Codes
	public static final long DAPI_SPECIAL_CMD_GET_MODULE_CONFIG						= 1;
	public static final long DAPI_SPECIAL_CMD_TIMEOUT								= 2;
	public static final long DAPI_SPECIAL_CMD_DI									= 10;
	public static final long DAPI_SPECIAL_CMD_SET_DIR_DX_1							= 3;
	public static final long DAPI_SPECIAL_CMD_SET_DIR_DX_8							= 4;
	public static final long DAPI_SPECIAL_CMD_GET_MODULE_VERSION					= 5;
	public static final long DAPI_SPECIAL_CMD_DA									= 6;
	public static final long DAPI_SPECIAL_CMD_WATCHDOG								= 7;
	public static final long DAPI_SPECIAL_CMD_COUNTER								= 8;
	public static final long DAPI_SPECIAL_CMD_AD									= 9;
	public static final long DAPI_SPECIAL_CMD_CNT48									= 11;
	public static final long DAPI_SPECIAL_CMD_SOFTWARE_FIFO							= 12;
	public static final long DAPI_SPECIAL_CMD_MODULE_REBOOT							= 13;
	public static final long DAPI_SPECIAL_CMD_MODULE_RESCAN							= 14;
	public static final long DAPI_SPECIAL_CMD_RESTART_CHECK_MODULE_CONFIG			= 15;

	// values for PAR1
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI					= 1;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF				= 7;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER			= 8;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO					= 2;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX					= 3;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD					= 4;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA					= 5;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP				= 9;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER				= 6;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48				= 10;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN			= 11;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT				= 12;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_INTERFACE1		= 13;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_FEATURE1			= 14;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_GROUP			= 15;
	public static final long DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_CLASS			= 16;
	//
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0					= 0;
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1					= 1;
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2					= 2;
	public static final long DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3					= 3;
	//
	public static final long DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC						= 1;
	public static final long DAPI_SPECIAL_TIMEOUT_ACTIVATE							= 2;
	public static final long DAPI_SPECIAL_TIMEOUT_DEACTIVATE						= 3;
	public static final long DAPI_SPECIAL_TIMEOUT_GET_STATUS						= 4;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_LOAD_DEFAULT				= 5;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_CLR32			= 6;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_CLR32			= 7;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_WR_SET32			= 8;
	public static final long DAPI_SPECIAL_TIMEOUT_DO_VALUE_MASK_RD_SET32			= 9;
	//
	public static final long DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET					= 1;
	public static final long DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET					= 2;
	//
	public static final long DAPI_SPECIAL_AD_READ_MULTIPLE_AD						= 1;
	public static final long DAPI_SPECIAL_AD_FIFO_ACTIVATE							= 2;
	public static final long DAPI_SPECIAL_AD_FIFO_DEACTIVATE						= 3;
	public static final long DAPI_SPECIAL_AD_FIFO_GET_STATUS						= 4;
	public static final long DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS					= 5;
	public static final long DAPI_SPECIAL_AD_FIFO_SET_CHANNEL						= 6;
	public static final long DAPI_SPECIAL_AD_FIFO_INIT								= 7;
	public static final long DAPI_SPECIAL_AD_FILTER_SET								= 8;
	public static final long DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT					= 1;
	public static final long DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG				= 2;
	public static final long DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG				= 3;
	//
	public static final long DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC					= 1;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC					= 2;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_STATUS						= 3;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC				= 4;
	public static final long DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC	= 5;
	public static final long DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC	= 6;
	public static final long DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC	= 7;
	//
	public static final long DAPI_SPECIAL_COUNTER_LATCH_ALL							= 1;
	public static final long DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET				= 2;
	//
	public static final long DAPI_SPECIAL_CNT48_RESET_SINGLE						= 1;
	public static final long DAPI_SPECIAL_CNT48_RESET_GROUP8						= 2;
	public static final long DAPI_SPECIAL_CNT48_LATCH_GROUP8						= 3;
	public static final long DAPI_SPECIAL_CNT48_DI_GET1								= 4;
	//
	public static final long DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE					= 1;
	public static final long DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE					= 2;
	public static final long DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS					= 3;

	// values for PAR2
	public static final long DAPI_SPECIAL_AD_CH0_CH15								= 0;
	public static final long DAPI_SPECIAL_AD_CH16_CH31								= 1;

	// ----------------------------------------------------------------------------
	// DapiScanModules-Codes
	public static final long DAPI_SCANMODULE_GET_MODULES_AVAILABLE					= 1;

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// DI - Counter Mode

	public static final long DAPI_CNT_MODE_READ_WITH_RESET							= 0x01; 
	public static final long DAPI_CNT_MODE_READ_LATCHED								= 0x02;
	public static final long DAPI_SW_CLASS_AD_DA_CHANNELS							= 0x04;

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// A/D and D/A Modes
	
	public static final long ADDA_MODE_UNIPOL_10V 									= 0x00;
	public static final long ADDA_MODE_UNIPOL_5V 									= 0x01;
	public static final long ADDA_MODE_UNIPOL_2V5 									= 0x02;
	
	public static final long ADDA_MODE_BIPOL_10V 									= 0x40;
	public static final long ADDA_MODE_BIPOL_5V 									= 0x41;
	public static final long ADDA_MODE_BIPOL_2V5 									= 0x42;
	
	public static final long ADDA_MODE_0_20mA 										= 0x80;
	public static final long ADDA_MODE_4_20mA										= 0x81;
	public static final long ADDA_MODE_0_24mA 										= 0x82;

	public static final long ADDA_MODE_DA_DISABLE 									= 0x100;
	public static final long ADDA_MODE_DA_ENABLE 									= 0x200;
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// Stepper-Defines

	// ------------------------------------
	// ERROR Codes
	public static final long DAPI_STEPPER_ERR_NONE									= 0;		// es liegt kein Fehler vor 
	public static final long DAPI_STEPPER_ERR_PARAMETER								= 1;		// Parameter hat falschen Wertebereich 
	public static final long DAPI_STEPPER_ERR_MOTOR_MOVE							= 2;		// Kommando abgelehnt, da sich der Motor dreht
	public static final long DAPI_STEPPER_ERR_DISABLE_MOVE							= 3;		// Kommando abgehelnt, da Motorbewegung disabled ist
	public static final long DAPI_STEPPER_ERR_DEVICE_NOT_FOUND						= -1;		// es liegt kein Fehler vor 

	// ------------------------------------
	// Special Stepper Function-Codes
	public static final long DAPI_STEPPER_RETURN_0_BYTES 							= 0x00000000;		// Kommando schickt 0 Byte als Antwort
	public static final long DAPI_STEPPER_RETURN_1_BYTES 							= 0x40000000;		// Kommando schickt 1 Byte als Antwort
	public static final long DAPI_STEPPER_RETURN_2_BYTES 							= 0x80000000;		// Kommando schickt 2 Byte als Antwort
	public static final long DAPI_STEPPER_RETURN_4_BYTES 							= 0xc0000000;		// Kommando schickt 4 Byte als Antwort

	public static final long DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC               = ( 0x00000001 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GET_MOTORCHARACTERISTIC               = ( 0x00000002 + DAPI_STEPPER_RETURN_4_BYTES ); 
	public static final long DAPI_STEPPER_CMD_SET_POSITION                          = ( 0x00000003 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GO_POSITION                           = ( 0x00000004 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GET_POSITION                          = ( 0x00000005 + DAPI_STEPPER_RETURN_4_BYTES );  
	public static final long DAPI_STEPPER_CMD_SET_FREQUENCY                         = ( 0x00000006 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_SET_FREQUENCY_DIRECTLY                = ( 0x00000007 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GET_FREQUENCY                         = ( 0x00000008 + DAPI_STEPPER_RETURN_2_BYTES );  
	public static final long DAPI_STEPPER_CMD_FULLSTOP                              = ( 0x00000009 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_STOP                                  = ( 0x00000010 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_GO_REFSWITCH                          = ( 0x00000011 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_DISABLE                               = ( 0x00000014 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_LOAD_DEFAULT		= ( 0x00000015 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_SAVE		= ( 0x00000016 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_LOAD		= ( 0x00000017 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_GET_CPU_TEMP							= ( 0x00000018 + DAPI_STEPPER_RETURN_1_BYTES );
	public static final long DAPI_STEPPER_CMD_GET_MOTOR_SUPPLY_VOLTAGE				= ( 0x00000019 + DAPI_STEPPER_RETURN_2_BYTES );
	public static final long DAPI_STEPPER_CMD_GO_POSITION_RELATIVE                  = ( 0x00000020 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_EEPROM_ERASE							= ( 0x00000021 + DAPI_STEPPER_RETURN_0_BYTES );  
	public static final long DAPI_STEPPER_CMD_SET_VECTORMODE                        = ( 0x00000040 + DAPI_STEPPER_RETURN_0_BYTES );
	public static final long DAPI_STEPPER_CMD_GET_STATUS                            = ( 0x00000015 + DAPI_STEPPER_RETURN_1_BYTES );

	// ------------------------------------
	// values for PAR1 for DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC

	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STEPMODE					= 1;					// Schrittmode (Voll-, Halb-, Viertel-, Achtel-, Sechszehntelschritt 
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOFREQUENCY					= 2;					// Schrittfrequenz bei GoPosition [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STARTFREQUENCY				= 3;					// Startfrequenz [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STOPFREQUENCY				= 4;					// Stopfrequenz [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_MAXFREQUENCY				= 5;					// maximale Frequenz [Vollschritt / s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_ACCELERATIONSLOPE			= 6;					// Beschleunigung in [Vollschritten / ms]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_DECELERATIONSLOPE			= 7;					// Bremsung in [Vollschritten / ms]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_PHASECURRENT				= 8;					// Phasenstrom [mA]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_HOLDPHASECURRENT			= 9;					// Phasenstrom bei Motorstillstand [mA]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_HOLDTIME 					= 10;					// Zeit in der der Haltestrom flie�t nach Motorstop [s]
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_STATUSLEDMODE				= 11;					// Betriebsart der Status-LED
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW1				= 12;					// invertiere Funktion des Endschalter1  
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW2				= 13;					// invertiere Funktion des Endschalter12 
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW1				= 14;					// invertiere Funktion des Referenzschalterschalter1
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW2				= 15;					// invertiere Funktion des Referenzschalterschalter2
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_INVERT_DIRECTION 			= 16;					// invertiere alle Richtungsangaben
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_ENDSWITCH_STOPMODE			= 17;					// Bei Endschalter soll (0=full stop/1=stop mit rampe)
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOENDSWITCH	= 18;			// Motor Frequency for GoReferenceCommand
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_AFTERENDSWITCH	= 19;			// Motor Frequency for GoReferenceCommand
	public static final long DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOOFFSET 		= 20;			// Motor Frequency for GoReferenceCommand

	// ----------------------------------------------------------------------------
	// values for PAR1 for DAPI_STEPPER_CMD_GO_REFSWITCH

	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF1						= 1;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF2						= 2;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_LEFT					= 4;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_RIGHT				= 8;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_POSITIVE			= 16;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_NEGATIVE			= 32;
	public static final long DAPI_STEPPER_GO_REFSWITCH_PAR_SET_POS_0				= 64;

	// ------------------------------------
	// Stepper Read Status
	
	public static final long DAPI_STEPPER_STATUS_GET_POSITION						= 0x01;
	public static final long DAPI_STEPPER_STATUS_GET_SWITCH							= 0x02;
	public static final long DAPI_STEPPER_STATUS_GET_ACTIVITY						= 0x03;
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// CNT48 Commands

	public static final long DAPI_CNT48_FILTER_20ns									= 0x0000;
	public static final long DAPI_CNT48_FILTER_100ns								= 0x1000;
	public static final long DAPI_CNT48_FILTER_250ns								= 0x2000;
	public static final long DAPI_CNT48_FILTER_500ns								= 0x3000;
	public static final long DAPI_CNT48_FILTER_1us									= 0x4000;
	public static final long DAPI_CNT48_FILTER_2_5us								= 0x5000;
	public static final long DAPI_CNT48_FILTER_5us									= 0x6000;
	public static final long DAPI_CNT48_FILTER_10us									= 0x7000;
	public static final long DAPI_CNT48_FILTER_25us									= 0x8000;
	public static final long DAPI_CNT48_FILTER_50us									= 0x9000;
	public static final long DAPI_CNT48_FILTER_100us								= 0xA000;
	public static final long DAPI_CNT48_FILTER_250us								= 0xB000;
	public static final long DAPI_CNT48_FILTER_500us								= 0xC000;
	public static final long DAPI_CNT48_FILTER_1ms									= 0xD000;
	public static final long DAPI_CNT48_FILTER_2_5ms								= 0xE000;
	public static final long DAPI_CNT48_FILTER_5ms									= 0xF000;

	public static final long DAPI_CNT48_MODE_COUNT_RISING_EDGE						= 0x0000;
	public static final long DAPI_CNT48_MODE_T										= 0x000D;
	public static final long DAPI_CNT48_MODE_FREQUENCY								= 0x000E;
	public static final long DAPI_CNT48_MODE_PWM									= 0x000F;

	public static final long DAPI_CNT48_SUBMODE_NO_RESET							= 0x0000;
	public static final long DAPI_CNT48_SUBMODE_RESET_WITH_READ 					= 0x0010;
	public static final long DAPI_CNT48_SUBMODE_RESET_ON_CH_7 						= 0x0070;
	public static final long DAPI_CNT48_SUBMODE_LATCH_COMMON 						= 0x0080;

	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// DELIB-Functions
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// Management
	
	public long DapiOpenModuleEx(String ipAdresseDeditec, long portNoDeditec, long timeout_ms) throws Exception
	{
		try 
		{	
			// set input_socket settings
			socket = new Socket();
			socket.connect(new InetSocketAddress(ipAdresseDeditec, (int) portNoDeditec), (int) timeout_ms);
			
		    // set input/output stream to SOCKETcket
		    input_stream = socket.getInputStream();
		    output_stream = socket.getOutputStream();
		}
		finally {}
		
		long handle = 0x1234;
		return handle;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiCloseModule() throws Exception
	{
		try 
		{
			socket.close();
		}
		finally {}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// Register Access
	
	
	public void DapiDOSet1_WithTimer(long handle, long ch, long data, long time_ms)
	{
		DapiWriteLong(handle, 0x200, time_ms);
		DapiWriteWord(handle, 0x204, (ch << 8) | data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet1(long handle, long ch, long data)
	{
		long xx;
		long mask;
	
		xx = DapiDOReadback32(handle, ch&0xffe0);
	
		mask = 1 << (ch&31);
	
		if(data == 0)
		{
			// clear Bit
			xx = xx & (~mask);
		}
		else
		{
			// set Bit
			xx = xx | mask;
		}
	
		DapiDOSet32(handle, ch&0xffe0, xx);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet8(long handle, long ch, long data)
	{					
		DapiWriteByte(handle, (ch>>3) & 0x1f, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet16(long handle, long ch, long data)
	{
		DapiWriteWord(handle, (ch>>3) & (~1) & 0x1f, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDOSet32(long handle, long ch, long data)
	{
		DapiWriteLong(handle, (ch>>3) & (~3) & 0x1f, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet1(long handle, long ch)
	{
		long xx;
		long mask;
	
		xx = DapiDIGet8(handle, ch&0xfff8);
	
		mask = 1 << (ch&7);
		if((xx&mask) == 0)
		{
			return 0;
		}
		else
		{
			return 1;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet8(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadByte(handle, 0x20 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet16(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadWord(handle, 0x20 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGet32(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadLong(handle, 0x20 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGetFF32(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadLong(handle, 0x40 | ((ch>>3) & 0x1f));
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDIGetCounter(long handle, long ch, long mode)
	{
		long adr;
		long ret;
	
		adr = 0x100 + (ch&0x1f)*2;
		if(mode == DAPI_CNT_MODE_READ_WITH_RESET)
		{
			adr+=0x100;
		}
		else if(mode == DAPI_CNT_MODE_READ_LATCHED)
		{
			adr+=0x200;
		}
	
		ret = DapiReadWord(handle, adr);
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDOReadback32(long handle, long ch)
	{
		long ret;
	
		ret = DapiReadLong(handle, (ch>>3) & 0x1f);
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiADSetMode(long handle, long ch, long mode)
	{
		DapiWriteByte(handle, 0x1000 + ch*4 + 3, mode);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiADGetMode(long handle, long ch)
	{
		return DapiReadByte(handle, 0x1000 + ch*4 + 3);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiADGet(long handle, long ch)
	{
		long ret;
	
		if ((ch & 0x8000) == 0)
		{
			return DapiReadWord(handle, 0x1000 + ch*4);
		}
		else
		{
			ret  = ((long) global_ad_buffer[(int) ((ch&63) * 4) + 0]);
			ret |= ((long) global_ad_buffer[(int) ((ch&63) * 4) + 1]) << 8;
			return ret;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public float DapiADGetVolt(long handle, long ch)
	{
		long data;
		long mode;
		float value=0;
	
		if ((ch & 0x8000) == 0)
		{
			data = DapiReadLong(handle, 0x1000 + ch*4);
		}
		else
		{
			data = ((long) global_ad_buffer[(int) ((ch&127) * 4) + 0]);
			data|= ((long) global_ad_buffer[(int) ((ch&127) * 4) + 1]) << 8;
			data|= ((long) global_ad_buffer[(int) ((ch&127) * 4) + 2]) << 16;
			data|= ((long) global_ad_buffer[(int) ((ch&127) * 4) + 3]) << 24;
		}
	
		mode = (data >> 24) & 0xff;
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_UNIPOL_10V:
				// 0-10V
				value = (((float) (data&0xffff)) *10.0F / 65536.0F);
				break;
	
			case (int) ADDA_MODE_UNIPOL_5V:
				// 0-5V
				value = (((float) (data&0xffff)) *5.0F / 65536.0F);
				break;
	
			case (int) ADDA_MODE_BIPOL_10V:
				// +-10V
				value = (((float) (data&0xffff)) *20.0F / 65536.0F) - 10.0F;
				break;
	
			case (int) ADDA_MODE_BIPOL_5V:
				// +-5V
				value = (((float) (data&0xffff)) *10.0F / 65536.0F) - 5.0F;
				break;
	
			default:					
				break;
		}
		return value;
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public float DapiADGetmA(long handle, long ch)
	{
		long data;
		long mode;
		float value=0;
	
		if ((ch & 0x8000) == 0)
		{
			data = DapiReadLong(handle, 0x1000 + ch*4);
		}
		else
		{
			data = global_ad_buffer[(int) ch&63];
		}
	
	
		mode = data >> 24;
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_0_24mA:
			case (int) ADDA_MODE_0_20mA:
			case (int) ADDA_MODE_4_20mA:
				// 0-5V entspricht 0-25mA (100 Ohm) und Spannungsverdopplung !
				value = (((float) (data&0xffff)) *25.0F / 65536.0F);
				break;
	
			default:			
				break;
	
		}
	
		
		return value;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASetMode(long handle, long ch, long mode)
	{
		DapiWriteByte(handle, 0x2000 + ch*8 + 2, mode&255);
	
		if((mode & ADDA_MODE_DA_DISABLE) == ADDA_MODE_DA_DISABLE)
		{
			DapiWriteByte(handle, 0x2000 + ch*8 + 3, 1);	// Disable D/A Channel
		}
		if((mode & ADDA_MODE_DA_ENABLE) == ADDA_MODE_DA_ENABLE)
		{
			DapiWriteByte(handle, 0x2000 + ch*8 + 3, 0);	// Enable D/A Channel
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiDAGetMode(long handle, long ch)
	{
		return DapiReadByte(handle, 0x2000 + ch*8 + 2);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASet(long handle, long ch, long data)
	{
		DapiWriteWord(handle, 0x2000 + ch*8, data);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASetVolt(long handle, long ch, float volt)
	{
		long mode;
		long value;
		mode = 	DapiDAGetMode(handle, ch);
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_UNIPOL_10V:
				value = (long) (3276.8 *2.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			case (int) ADDA_MODE_UNIPOL_5V:
				value = (long) (3276.8 * 4.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_UNIPOL_2V5:
				value = (long) (3276.8 * 8.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_BIPOL_10V:
				value = (long) (32768.0 + 3276.8 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_BIPOL_5V:
				value = (long) (32768.0 + 3276.8 * 2.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			case (int) ADDA_MODE_BIPOL_2V5:
				value = (long) (32768.0 + 3276.8 * 4.0 * volt);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			default:	
				break;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiDASetmA(long handle, long ch, float data)
	{
		long mode;
		long value;
	
		mode = 	DapiDAGetMode(handle, ch);
	
		switch((int) mode)
		{
			case (int) ADDA_MODE_0_20mA:
				if(data<0) data=0;
				value = (long) (3276.8 * data);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			case (int) ADDA_MODE_4_20mA:
				if(data<4) data=4;
				value = (long) (4096 * (data-4.0));
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
			
			case (int) ADDA_MODE_0_24mA:
				if(data<4) data=4;
				value = (long) (65536/24 * data);
				if(value > 0xffff) value = 0xffff;
				DapiDASet(handle, ch, value );
				break;
	
			default:			
				break;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public float DapiTempGet(long handle, long ch)
	{
		float f;
		long d;
		
		if((ch&0x8000) == 0)
		{
			// Temperatur soll gelesen werden
			d = DapiReadLong(handle, 0x4000 + ch*8);
	
			switch((int) (d>>16) & 0xff)
			{
				case 1:	f = ((float) (d&0x7fff)) / 10;break;				// Faktor 10
				case 2:	f = ((float) (d&0x7fff)) / 100;break;				// Faktor 100
				case 0:	f = -9999;break;									// Faktor Sensor disconnected
				default: f=0;
				
			}
	
			if(((d>>15)&1) != 0) f=-f;			// Negative Temp
		
		}
		else
		{
			// Der Widerstandswert soll gelesen werden
			d = DapiReadWord(handle, 0x4000 + ch*8 + 6);				// Widerstandswert lesen
	
			f = ((float) (d&0x7fff)) / 100;								// Faktor 100
			if(((d>>15)&1) != 0) f=-f;									// Negative
		}
	
		return f;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiCnt48ModeSet(long handle, long ch, long mode)
	{
		DapiWriteWord(handle, 0x5000 + ch*8 + 6, mode);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiCnt48ModeGet(long handle, long ch)
	{	
		return DapiReadWord(handle, 0x5000 + ch*8 + 6);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiCnt48CounterGet32(long handle, long ch)
	{
		return DapiReadLong(handle, 0x5000 + ch*8);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiPulseGenSet(long handle, long ch, long mode, long par0, long par1, long par2)
	{
	
		DapiWriteLong(handle, 0x5800 + ch*16 + 0 , mode);
		DapiWriteLong(handle, 0x5800 + ch*16 + 4 , par0);
		DapiWriteLong(handle, 0x5800 + ch*16 + 8 , par1);
		DapiWriteLong(handle, 0x5800 + ch*16 + 12, par2);
	
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiPWMOutSet(long handle, long ch, float data)
	{
		DapiWriteByte(handle, 0x0800 + ch  , (long) data);
	
	}
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiSpecialCommand(long handle, long cmd, long par1, long par2, long par3)
	{
		long ret=0;
		long cnt;
	
		switch((int) cmd)
		{
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_DA:
				switch((int) par1)
				{
					// ----------------------------------------
					case (int) DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT:
						DapiWriteByte(handle, 0x2000 + par2*8 + 7, 0x12);		// Auslieferungszustand laden
	
						cnt=100;
						do
						{
							--cnt;
						} while((DapiReadByte(handle, 0x2000 + par2*8 + 7) != 0xff) && (cnt!=0));
	
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG:
						DapiWriteByte(handle, 0x2000 + par2*8 + 7, 0x10);		// Ins EEPROM schreiben
	
						cnt=100;
						do
						{
							--cnt;
						} while((DapiReadByte(handle, 0x2000 + par2*8 + 7) != 0xff) && (cnt!=0));
	
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG:
						DapiWriteByte(handle, 0x2000 + par2*8 + 7, 0x11);		// Aus EEPROM laden
	
						cnt=100;
						do
						{
							--cnt;
						} while((DapiReadByte(handle, 0x2000 + par2*8 + 7) != 0xff) && (cnt!=0));
	
						break;
					// ----------------------------------------
				}
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_AD:
				switch((int) par1)
				{
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_READ_MULTIPLE_AD:
						if(par2>64) return -1;
						if(par3>64) return -1;
						if(par2>par3) return -1;
						

						byte[] temp_ad_buffer = new byte[((int)par3-(int)par2 + 1)*4];
						ret=DapiReadMultipleBytes(handle, 0x1000 + par2*4, (par3-par2+1)*4, 1, temp_ad_buffer, temp_ad_buffer.length);
						System.arraycopy(temp_ad_buffer, 0, global_ad_buffer, ((int)par2*4), temp_ad_buffer.length);
						
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_DEACTIVATE:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_disable | (0<<8));
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_ACTIVATE:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_disable | (1<<8));
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_INIT:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_init | (0<<8));
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_set_intervalL | ((par3&255)           <<8));
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_set_intervalH | ((par3>>8) & 255)     <<8);
						break;
					// ----------------------------------------
					case (int) DAPI_SPECIAL_AD_FIFO_SET_CHANNEL:
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_chL | ((par3&255)          <<8));
						DapiWriteWord(handle, 0x1400 + par2*4, RO_FIFO_CMD_fifo_enable_chH | ((par3>>8) & 255)    <<8);
						break;
					// ----------------------------------------
				}
				break;

			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
	
	
						
						
			// ------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_SET_DIR_DX_8:
				DapiWriteLong(handle, 0x100 + par1/64, par2);
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_SET_DIR_DX_1:
				DapiWriteLong(handle, 0x120 + par1/8, par2);
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_GET_MODULE_CONFIG:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO:
					ret = DapiReadByte(handle, 0xff00);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI:
					ret = DapiReadByte(handle, 0xff02);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF:
					ret = DapiReadByte(handle, 0xff0c);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER:
					ret = DapiReadByte(handle, 0xff0e);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX:
					ret = DapiReadByte(handle, 0xff04);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD:
					ret = DapiReadByte(handle, 0xff08);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA:
					ret = DapiReadByte(handle, 0xff06);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER:
					ret = DapiReadByte(handle, 0xff0a);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP:
					ret = DapiReadByte(handle, 0xff10);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48:
					ret = DapiReadByte(handle, 0xff12);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN:
					ret = DapiReadByte(handle, 0xff14);
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT:
					ret = DapiReadByte(handle, 0xff16);
					break;
	
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_GET_MODULE_VERSION:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0:
					ret = DapiReadByte(handle, 0xfff4) - '0';
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1:
					ret = DapiReadByte(handle, 0xfff5) - '0';
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2:
					ret = DapiReadByte(handle, 0xfff6) - '0';
					break;
	
				case (int) DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3:
					ret = DapiReadByte(handle, 0xfff7) - '0';
					break;
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_TIMEOUT:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC:
					DapiWriteWord(handle, 0xfd02, par2*10+ (par3%10));
					break;
	
				case (int) DAPI_SPECIAL_TIMEOUT_ACTIVATE:
					DapiWriteByte(handle, 0xfd00,1);
					break;
	
				case (int) DAPI_SPECIAL_TIMEOUT_DEACTIVATE:
					DapiWriteByte(handle, 0xfd00,0);
					break;
	
				case (int) DAPI_SPECIAL_TIMEOUT_GET_STATUS:
					ret = DapiReadByte(handle, 0xfd01);
					break;
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_DI:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET:
					DapiWriteByte(handle, 0xfd10, par2);
					break;
				case (int) DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET:
					ret = DapiReadByte(handle, 0xfd10);
					break;
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_WATCHDOG:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC:
					DapiWriteLong(handle, 0xe004, par2);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC:
					ret = DapiReadLong(handle, 0xe004);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_STATUS:
					ret=DapiReadByte(handle, 0xe000);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC:
					ret = DapiReadLong(handle, 0xe008);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC:
					ret = DapiReadLong(handle, 0xe00c);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC:
					DapiWriteLong(handle, 0xe008, par2);
					break;
	
				case (int) DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC:
					DapiWriteLong(handle, 0xe00c, par2);
					break;
	
				
				}
				break;
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_COUNTER:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_COUNTER_LATCH_ALL:
					DapiWriteByte(handle, 0xfe12, 0x19);					// Latch all Counter
					break;
				case (int) DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET:
					DapiWriteByte(handle, 0xfe12, 0x1a);					// Latch all Counter WITH RESET
					break;
				}
				break;
	
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_CNT48:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_CNT48_RESET_SINGLE:
					DapiWriteByte(handle, 0x5000 + par2*8, 0x00);			// Reset Counter Nr. "par2"
					break;
				case (int) DAPI_SPECIAL_CNT48_RESET_GROUP8:
					DapiWriteByte(handle, 0x5003 + (par2/8)*0x40, 0x00);	// Reset Counter Group Nr. "par2"
					break;
				case (int) DAPI_SPECIAL_CNT48_LATCH_GROUP8:
					DapiWriteByte(handle, 0x5002 + (par2/8)*0x40, 0x00);	// Latch Counter Group Nr. "par2"
					break;
				case (int) DAPI_SPECIAL_CNT48_DI_GET1:
					ret = DapiReadByte(handle, 0x5007 + (par2*8)) & 1;			// Bit 0 Latch Counter Group Nr. "par2"
	
					break;
				}
				break;
				
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			// -----------------------------------------------------------------------------------------
			case (int) DAPI_SPECIAL_CMD_SOFTWARE_FIFO:
				switch((int) par1)
				{
				case (int) DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE:
					DapiWriteByte(handle, 0xfe30, 0x01);					// activate software fifo
					break;
				case (int) DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE:
					DapiWriteByte(handle, 0xfe30, 0x00);					// deactivate software fifo
					break;	
				case (int) DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS:
					ret = DapiReadByte(handle, 0xfe30) & 1;					// read software-fifo status (activated / deactivated)
					break;
				}
				break;			
		}
		
		return ret;
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiStepperCommand(long handle, long motor, long cmd, long par1, long par2, long par3, long par4)
	{
		long ret;
		long adr_base = (0x3000 | (motor*0x40));
		ret=0;
		byte[] buff = new byte[20];
		int pos;
	
		pos = 0;
	
		
		buff[pos++] = (byte) ((par3)     & 0xff);
		buff[pos++] = (byte) ((par3>>8)  & 0xff);
		buff[pos++] = (byte) ((par3>>16) & 0xff);
		buff[pos++] = (byte) ((par3>>24) & 0xff);
	
		buff[pos++] = (byte) ((par2)     & 0xff);
		buff[pos++] = (byte) ((par2>>8)  & 0xff);
		buff[pos++] = (byte) ((par2>>16) & 0xff);
		buff[pos++] = (byte) ((par2>>24) & 0xff);
	
		buff[pos++] = (byte) ((par1)     & 0xff);
		buff[pos++] = (byte) ((par1>>8)  & 0xff);
		buff[pos++] = (byte) ((par1>>16) & 0xff);
		buff[pos++] = (byte) ((par1>>24) & 0xff);
	
		buff[pos++] = (byte) ((cmd)     & 0xff);
		buff[pos++] = (byte) ((cmd>>8)  & 0xff);
		buff[pos++] = (byte) ((cmd>>16) & 0xff);
		buff[pos++] = (byte) ((cmd>>24) & 0xff);
		
		
		DapiWriteMultipleBytes(handle, adr_base + 0x10 , pos, 1, buff , pos);
	
	
		if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_0_BYTES)
		{
			ret=0;
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_1_BYTES)
		{
			ret=DapiReadByte(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_2_BYTES)
		{
			ret=DapiReadWord(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_4_BYTES)
		{
			ret=DapiReadLong(handle, (adr_base | 0x20));
		}
		
		
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------

	public long DapiStepperCommandEx(long handle, long motor, long cmd, long par1, long par2, long par3, long par4, long par5, long par6, long par7)
	{
		long ret;
		long adr_base = 0x3000 | motor*0x40;
		ret=0;
	
	
	
		byte[] buff = new byte[40];
		int pos;
	
		pos = 0;
	
		buff[pos++] = (byte) ((par7)     & 0xff);
		buff[pos++] = (byte) ((par7>>8)  & 0xff);
		buff[pos++] = (byte) ((par7>>16) & 0xff);
		buff[pos++] = (byte) ((par7>>24) & 0xff);
	
		buff[pos++] = (byte) ((par6)     & 0xff);
		buff[pos++] = (byte) ((par6>>8)  & 0xff);
		buff[pos++] = (byte) ((par6>>16) & 0xff);
		buff[pos++] = (byte) ((par6>>24) & 0xff);
	
		buff[pos++] = (byte) ((par5)     & 0xff);
		buff[pos++] = (byte) ((par5>>8)  & 0xff);
		buff[pos++] = (byte) ((par5>>16) & 0xff);
		buff[pos++] = (byte) ((par5>>24) & 0xff);
	
		buff[pos++] = (byte) ((par4)     & 0xff);
		buff[pos++] = (byte) ((par4>>8)  & 0xff);
		buff[pos++] = (byte) ((par4>>16) & 0xff);
		buff[pos++] = (byte) ((par4>>24) & 0xff);
	
		buff[pos++] = (byte) ((par3)     & 0xff);
		buff[pos++] = (byte) ((par3>>8)  & 0xff);
		buff[pos++] = (byte) ((par3>>16) & 0xff);
		buff[pos++] = (byte) ((par3>>24) & 0xff);
	
		buff[pos++] = (byte) ((par2)     & 0xff);
		buff[pos++] = (byte) ((par2>>8)  & 0xff);
		buff[pos++] = (byte) ((par2>>16) & 0xff);
		buff[pos++] = (byte) ((par2>>24) & 0xff);
	
		buff[pos++] = (byte) ((par1)     & 0xff);
		buff[pos++] = (byte) ((par1>>8)  & 0xff);
		buff[pos++] = (byte) ((par1>>16) & 0xff);
		buff[pos++] = (byte) ((par1>>24) & 0xff);
	
		buff[pos++] = (byte) ((cmd)     & 0xff);
		buff[pos++] = (byte) ((cmd>>8)  & 0xff);
		buff[pos++] = (byte) ((cmd>>16) & 0xff);
		buff[pos++] = (byte) ((cmd>>24) & 0xff);
	
		DapiWriteMultipleBytes(handle, adr_base + 0x00 , pos, 1, buff , pos);
	
		if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_0_BYTES)
		{
			ret=0;
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_1_BYTES)
		{
			ret=DapiReadByte(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_2_BYTES)
		{
			ret=DapiReadWord(handle, (adr_base | 0x20));
		}
		else if ((cmd & 0xc0000000) == DAPI_STEPPER_RETURN_4_BYTES)
		{
			ret=DapiReadLong(handle, (adr_base | 0x20));
		}
		
	
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiStepperGetStatus(long handle, long motor, long cmd)
	{
		long ret;
		long adr_base = 0x3000 | motor*0x40;
		ret=0;

		if (cmd == DAPI_STEPPER_STATUS_GET_POSITION)
		{
			ret = DapiReadLong(handle, (adr_base | 0x28));
		}
		else if (cmd == DAPI_STEPPER_STATUS_GET_SWITCH)
		{
			ret = DapiReadByte(handle, (adr_base | 0x2f));
		}
		else if (cmd == DAPI_STEPPER_STATUS_GET_ACTIVITY)
		{
			ret = DapiReadByte(handle, (adr_base | 0x2e));
		}
		
		return ret;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWatchdogEnable(long handle)
	{
		DapiWriteByte(handle, 0xe000, 0x23);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWatchdogDisable(long handle)
	{
		DapiWriteByte(handle, 0xe000, 0x12);
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWatchdogRetrigger(long handle)
	{
		DapiWriteByte(handle, 0xe001, 0x34);
	}
	
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWriteByte(long handle, long address, long value) 
	{
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// socket
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'W';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'B';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[tx_pos++] = (byte) (value & 0xff);				// DATA_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWriteWord(long handle, long address, long value) {
		
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'W';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'W';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[tx_pos++] = (byte) ((value >> 8) & 0xff);			// DATA_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((value >> 0) & 0xff);			// DATA_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void DapiWriteLong(long handle, long address, long value) 
	{		
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'W';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'L';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[tx_pos++] = (byte) ((value >> 24) & 0xff);		// DATA_BIT_24_31
		tx_buffer[tx_pos++] = (byte) ((value >> 16) & 0xff);		// DATA_BIT_16_23
		tx_buffer[tx_pos++] = (byte) ((value >> 8 ) & 0xff);		// DATA_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((value >> 0 ) & 0xff);		// DATA_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) {
			job_id = 0;
		}	
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
		}
		
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadByte(long handle, long address) 
	{
		int tx_pos = 0;
		int rx_pos = 7;
		long data;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'R';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'B';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
	
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
			
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 0;
		}
		
		// calculate data
		data = ((rx_buffer[rx_pos++] << 0 ) & 0xffL);
		
		return data;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadWord(long handle, long address) 
	{
		int tx_pos = 0;
		int rx_pos = 7;
		long data;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'R';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'W';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}	
		
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 0;
		}
		
		// calculate data
		data = 	((rx_buffer[rx_pos++] << 0 ) & 0xffL);
		data += ((rx_buffer[rx_pos++] << 8 ) & 0xff00L);
		
		return data;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadLong(long handle, long address) 
	{
		int tx_pos = 0;
		int rx_pos = 7;
		long data;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++] = (byte) 'R';							// COMMAND
		tx_buffer[tx_pos++] = (byte) 'L';							// WIDTH
		
		tx_buffer[tx_pos++] = (byte) ((address >> 8) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++] = (byte) ((address >> 0) & 0xff);		// ADDRESS_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				// LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				// LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 0;
		}
		
		// calculate data
		data = 	((rx_buffer[rx_pos++] << 0 ) & 0xffL);
		data += ((rx_buffer[rx_pos++] << 8 ) & 0xff00L);
		data += ((rx_buffer[rx_pos++] << 16) & 0xff0000L);
		data += ((rx_buffer[rx_pos++] << 24) & 0xff000000L);

		return data;
	}
	
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiReadMultipleBytes(long handle, long address, long address_depth, long increment, byte[] buff, long buff_len)
	{
		long i;
		long j;
		
		int pos = 0;
		int tx_pos = 0;
		int tx_cnt;
		
		long m_start_id;
		long m_data_id;
		long m_data_pos;
		
		// tx_buffer zusammenbauen
		tx_cnt=0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1
		
		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID
		
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
	
		tx_buffer[tx_pos++]='R';									// COMMAND
		tx_buffer[tx_pos++]='M';									// WIDTH
	
		// address (2byte)
		tx_buffer[tx_pos++]= (byte) ((address >> 8 ) & 0xff);		// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address >> 0 ) & 0xff);		// ADDRESS_BIT_0_7
		
		// address_depth (2byte)
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 8 ) & 0xff);	// ADDRESS_DEPTH_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 0 ) & 0xff);	// ADDRESS_DEPTH_BIT_0_7
		
		// increment (2byte)
		tx_buffer[tx_pos++]= (byte) ((increment >> 8 ) & 0xff);		// INCREMENT_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((increment >> 0 ) & 0xff);		// INCREMENT_BIT_0_7
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				// LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				// LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}
		
		try 
		{
			output_stream.write(tx_buffer, 0, tx_pos);
			output_stream.flush();
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 1;
		}
	
		// data_temp �berpr�fen
		// datenblock = start_id_multiple_byte(1) +  data_id(2) + addr_depth	
	
		for (i=0; i<increment; i++)
		{
			pos = 0;
			m_data_pos = i*(address_depth+3);
			
			// start_id + data_id aus dem buffer filtern
			m_start_id = rx_buffer[(int) (7 + (m_data_pos + (pos++)))];
			m_data_id = rx_buffer[(int) (7 + (m_data_pos + (pos++)))];
			m_data_id = (m_data_id << 8) | rx_buffer[(int) (7 + (m_data_pos + (pos++)))];
			
			// start_id checken
			if (m_start_id != DEDITEC_TCP_START_ID_FOR_MULTIPLE_BYTE_DATA)
			{
				return 1;			// Error
			}
			
			// data_id checken
			if (m_data_id != i)
			{
				return 1;			// Error
			}
			
		}
		
		// daten sind ok - daten in "richtigen buffer" schreiben
		tx_cnt = 0;
		
		for (i=0; i< increment; i++)
		{
			for (j=0; j<address_depth; j++)
			{
				buff[tx_cnt++] = rx_buffer[(int) (7 + 3 + j + i*(address_depth+3))];
			}
		}
	
		return 0;
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public long DapiWriteMultipleBytes(long handle, long address, long address_depth, long increment, byte[] buff, long buff_len)
	{
		long i;
		long j;
		
		int pos = 0;
		int tx_pos = 0;
		
		tx_buffer[tx_pos++] = (byte) 0x63;							// Packet_ID_o
		tx_buffer[tx_pos++] = (byte) 0x9a;							// Packet_ID_1

		tx_buffer[tx_pos++] = (byte) 0x01;							// TCP_CMD_RO_1
		tx_buffer[tx_pos++] = (byte) job_id++;						// JOB_ID

		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit8-15
		tx_buffer[tx_pos++] = (byte) 0;								// Placeholder for LENGTH Bit0-7
		
		tx_buffer[tx_pos++]='W';									// COMMAND //Write
		tx_buffer[tx_pos++]='M';									// WIDTH //Multiple

		// address (2byte)
		tx_buffer[tx_pos++]= (byte) ((address >> 8 ) & 0xff);	// ADDRESS_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address >> 0 ) & 0xff);	// ADDRESS_BIT_0_7
		
		// address_depth (2byte)
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 8 ) & 0xff);	// ADDRESS_DEPTH_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((address_depth >> 0 ) & 0xff);	// ADDRESS_DEPTH_BIT_0_7
		
		// increment (2byte)
		tx_buffer[tx_pos++]= (byte) ((increment >> 8 ) & 0xff);	// INCREMENT_BIT_8_15
		tx_buffer[tx_pos++]= (byte) ((increment >> 0 ) & 0xff);	// INCREMENT_BIT_0_7
		
		// data start
		for (i=0; i<increment; i++)
		{
			// START_ID_MULTIPLE_BYTE (1byte)
			tx_buffer[tx_pos++]= (byte) DEDITEC_TCP_START_ID_FOR_MULTIPLE_BYTE_DATA;		// START_ID_MULTIPLE_BYTE
			
			// DATA_ID (2byte)
			tx_buffer[tx_pos++]= (byte) ((i >> 8 ) & 0xff);			// DATA_ID_BIT_8_15
			tx_buffer[tx_pos++]= (byte) ((i >> 0 ) & 0xff);			// DATA_ID_BIT_0_7
			
			// data	
			for (j=0; j<address_depth; j++)
			{
				tx_buffer[tx_pos++] = buff[pos++];
			}
		}
		// data end
		
		
		tx_buffer[4] = (byte) ((tx_pos >> 8) & 0xff);				//LENGTH_BIT_8_15
		tx_buffer[5] = (byte) ((tx_pos >> 0) & 0xff);				//LENGTH_BIT_0_7
		
		if (job_id > 255) 
		{
			job_id = 0;
		}
		
		try 
		{
			output_stream.write(tx_buffer);
			output_stream.flush();			
			
			amount_bytes_received = input_stream.read(rx_buffer);
			CheckIsValidDeditecAnswer();
		}
		catch (IOException ioe)
		{
			SetError(DAPI_ERR_DEVICE_NOT_FOUND);
			return 1;
		}
		
		return 0;
	
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void CheckIsValidDeditecAnswer()
	{
		int recv_pos = 0;
		
		// PACKET_ID_0 checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_PACKET_ID_0)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
		
		// PACKET_ID_1 checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_PACKET_ID_1)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
		
		// TCP_ANSWER_RO_1 checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_TCP_ANSWER_RO_1)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
		
		// TCP_ANSWER_OK checken
		if((rx_buffer[recv_pos++] & 0xFFL) != DEDITEC_TCP_ANSWER_OK)
		{
			SetError(DAPI_ERR_COMMUNICATION_ERROR);
			return;
		}
	}
	
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public void SetError(long errorCode)
	{
		dapi_last_error = errorCode;
		
		switch ((int)errorCode)
		{
			case (int) DAPI_ERR_DEVICE_NOT_FOUND:
				dapi_last_error_text = "Device not found!";
				break;
				
			default:
				break;
		}
	}

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	
	public boolean IsError()
	{
		if (dapi_last_error != DAPI_ERR_NONE)
		{
			System.out.printf("Error - Error Code = 0x%x\nMessage = %s\n", dapi_last_error,dapi_last_error_text);
		
			// clear last error
			dapi_last_error = DAPI_ERR_NONE;
			
			return true;
		}
		
		return false;
	}

	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
	// ----------------------------------------------------------------------------
}
	

- DelibErrorCodes.java
  Inhalt:
package DelibJava;

//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//
//
//
//  DelibErrorCodes.java
//  project: DELIB
//
//
//  (c) DEDITEC GmbH, 2009-2016
//  web: http://www.deditec.de/
//  mail: vertrieb@deditec.de
//
//
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************
//***********************************************************************************

public class DelibErrorCodes
{
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0000        
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_NONE                                       = 0;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0100        Allgemeine Error Codes
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_GEN_CLASS                                  = 0x0100;
    //
    public static final int DAPI_ERR_GEN_MALLOC_ERROR                           = 0x0101;
    public static final int DAPI_ERR_GEN_BUFFER_TOO_SMALL_ERROR                 = 0x0102;
    public static final int DAPI_ERR_GEN_ERROR_WITH_TEXT                        = 0x0103;
    //
    public static final int DAPI_ERR_GEN_SOCKET_ERROR                           = 0x0110;
    public static final int DAPI_ERR_GEN_BINDING_ERROR                          = 0x0111;
    public static final int DAPI_ERR_GEN_SIG_HANDLER_ERROR                      = 0x0112;
    //
    public static final int DAPI_ERR_GEN_UNKNOWN_ENCRYPTION_TYPE                = 0x0120;
    public static final int DAPI_ERR_GEN_ENCRYPTION_ERROR                       = 0x0121;
    //
    public static final int DAPI_ERR_GEN_ILLEGAL_MODULE_ID                      = 0x0130;
    public static final int DAPI_ERR_GEN_ILLEGAL_MODULE_NR                      = 0x0131;
    public static final int DAPI_ERR_GEN_ILLEGAL_HANDLE                         = 0x0132;
    //
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_MODE                     = 0x0140;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_IO_TYPE                  = 0x0141;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_CHANNEL                  = 0x0142;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_SW_FEATURE               = 0x0143;
    public static final int DAPI_ERR_GEN_NOT_SUPPORTED_FUNCTION                 = 0x0144;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0200    Communication Errors
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_COM_CLASS                                  = 0x0200;
    //
    public static final int DAPI_ERR_COM_CONN_COULD_NOT_BE_ESTABLISHED          = 0x0201;
    public static final int DAPI_ERR_COM_DEVICE_DID_NOT_ANSWER                  = 0x0202;
    //
    public static final int DAPI_ERR_COM_HANDLE_INVALID                         = 0x0210;
    public static final int DAPI_ERR_COM_DELIB_ID_INVALID                       = 0x0211;
    public static final int DAPI_ERR_COM_FT_HANDLE_INVALID                      = 0x0212;
    public static final int DAPI_ERR_COM_FT_ERROR                               = 0x0213;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //  = 0x0300    Device Errors
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    //
    public static final int DAPI_ERR_DEV_CLASS                                  = 0x0300;
    //
    public static final int DAPI_ERR_DEV_PKT_CMD_ILLEGAL                        = 0x0301;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_ILLEGAL_COMMAND     1
    public static final int DAPI_ERR_DEV_PKT_DATA_LENGTH_ERROR                  = 0x0302;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_WRONG_DATA_LENGTH   2
    public static final int DAPI_ERR_DEV_PKT_DATA_CHECKSUM_ERROR                = 0x0303;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_WRONG_CHECKSUM      3
    public static final int DAPI_ERR_DEV_PKT_ADDR_NOT_FOR_ME                    = 0x0304;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_NOT_FOR_ME          4
    public static final int DAPI_ERR_DEV_PKT_OTHER_ERROR                        = 0x0305;       //ehemals ERR_EXECUTE_RS232_RX_COMMAND_NOT_FOR_ME          4
    //
    public static final int DAPI_ERR_DEV_PACKET_CMD_NOT_SUPPORTED               = 0x0310;       // BC-CMD or TCP-CMD
    public static final int DAPI_ERR_DEV_PACKET_ID_1_NOT_ALLOWED                = 0x0311;       // TCP
    public static final int DAPI_ERR_DEV_PACKET_ID_1_NOT_SUPPORTED              = 0x0312;       // TCP
    public static final int DAPI_ERR_DEV_PACKET_HEADER_NOT_OK                   = 0x0313;       // TCP
    public static final int DAPI_ERR_DEV_PACKET_SUBCMD_NOT_SUPPORTED            = 0x0314;       // TCP
    //
    public static final int DAPI_ERR_DEV_IO_ADDR_ILLEGAL                        = 0x0331;       // dev_io
    public static final int DAPI_ERR_DEV_IO_RD_WR_ERROR                         = 0x0332;       // dev_io
    public static final int DAPI_ERR_DEV_IO_SUB_ADDR_ILLEGAL                    = 0x0333;       // dev_io
    public static final int DAPI_ERR_DEV_IO_OTHER_ERROR                         = 0x0337;       // dev_io (7. von 7 mglichen Errors)
    public static final int DAPI_ERR_DEV_IO_HTML_ACCESS_DENIED                  = 0x0338;
    //
    public static final int DAPI_ERR_DEV_FS_INTERNAL_TEXT_BUFFER_TOO_SMALL      = 0x0345;
    public static final int DAPI_ERR_DEV_FS_RW_OFFSET_OUT_OF_SCOPE              = 0x0346;
    public static final int DAPI_ERR_DEV_FS_RW_LENGTH_OUT_OF_SCOPE              = 0x0347;
    public static final int DAPI_ERR_DEV_FS_BUFFER_TOO_SMALL                    = 0x0349;
    //
    public static final int DAPI_ERR_DEV_FILE_WRITE_ERROR                       = 0x0370;
    //
    public static final int DAPI_ERR_DEV_CONFIG_WRITE_PROTECTED                 = 0x0380;
    public static final int DAPI_ERR_DEV_CONFIG_KEY_NOT_PRESSED                 = 0x0381;
    public static final int DAPI_ERR_DEV_CONFIG_READ_ERROR                      = 0x0382;
    public static final int DAPI_ERR_DEV_CONFIG_WRITE_ERROR                     = 0x0383;
    public static final int DAPI_ERR_DEV_CONFIG_UPDATE_ERROR                    = 0x0384;       // Broadcast
    public static final int DAPI_ERR_DEV_CONFIG_PARAM_ONLY_ONE_TIME_WRITEABLE   = 0x0385;       // ETH
    public static final int DAPI_ERR_DEV_CONFIG_PARAM_IS_READ_ONLY              = 0x0386;
    public static final int DAPI_ERR_DEV_CONFIG_PARAM_IS_WRITE_ONLY             = 0x0387;
    public static final int DAPI_ERR_DEV_CONFIG_WRITE_PROTECTED_SW              = 0x0388;
    public static final int DAPI_ERR_DEV_CONFIG_FS_INVALID                      = 0x0389;
    public static final int DAPI_ERR_DEV_CONFIG_FS_DIR_NOT_FOUND                = 0x038a;
    public static final int DAPI_ERR_DEV_CONFIG_FS_DIR_ALREADY_EXIST            = 0x038b;
    public static final int DAPI_ERR_DEV_CONFIG_FS_IS_FULL                      = 0x038c;
    public static final int DAPI_ERR_DEV_CONFIG_FS_DIR_DATA_INVALID             = 0x038d;
    //
    public static final int DAPI_ERR_DEV_ENCRYPTED_HEADER_NOT_OK                = 0x0391;
    public static final int DAPI_ERR_DEV_ENCRYPTION_ERROR                       = 0x0392;       // Encryption
    public static final int DAPI_ERR_DEV_ENCRYPTION_TEMP_ADMIN_MODE_NOT_ALLOWED = 0x0393;
    public static final int DAPI_ERR_DEV_ENCRYPTION_NO_ADMIN_RIGHTS             = 0x0394;
    //
    public static final int DAPI_ERR_DEV_EXECUTE_CMD_ERROR                      = 0x03FF;
    //
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
}



[frontend]
- package.json
  Inhalt:
{
  "name": "motor-control-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "axios": "^1.3.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "^5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}



[frontend/public]
- index.html
  Inhalt:
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Motor Control</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>



[frontend/src]
- index.js
  Inhalt:
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


- index.css
  Inhalt:
body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  button {
    margin: 5px;
    padding: 10px 20px;
    cursor: pointer;
  }
  table {
    margin-bottom: 20px;
  }
  

- App.js
  Inhalt:
import React from 'react';
import MotorControl from './components/MotorControl';
import EmergencyStop from './components/EmergencyStop';
import StatusDisplay from './components/StatusDisplay';
import PinLayout from './components/PinLayout';

function App() {
  return (
    <div className="App">
      <h1>Motorsteuerung für dryve 16 D1</h1>
      <MotorControl />
      <EmergencyStop />
      <StatusDisplay />
      <PinLayout />
    </div>
  );
}

export default App;



[frontend/src/components]
- EmergencyStop.js
  Inhalt:
import React from 'react';
import axios from 'axios';

const EmergencyStop = () => {
  const handleEmergencyStop = async () => {
    try {
      const response = await axios.post('/api/motor/emergency-stop');
      console.log(response.data);
    } catch (error) {
      console.error('Fehler beim Not-Aus', error);
    }
  };

  return (
    <div>
      <h2>Not-Aus</h2>
      <button style={{ backgroundColor: 'red', color: 'white' }} onClick={handleEmergencyStop}>
        Not-Aus
      </button>
    </div>
  );
};

export default EmergencyStop;


- PinLayout.js
  Inhalt:
import React, { useState, useEffect } from 'react';
import axios from 'axios';

// Outputs-Daten
const outputsData = [
    // Dryve D1 Outputs (0-7)
    { id: 0, label: "DI1 - Referenzfahrt", group: "dryve" },
    { id: 1, label: "DI4 - Tippen links", group: "dryve" },
    { id: 2, label: "DI5 - Tippen rechts", group: "dryve" },
    { id: 3, label: "DI6 - Start/Teach", group: "dryve" },
    { id: 4, label: "DI7 - Freigabe", group: "dryve" },
    { id: 5, label: "DI8 - Endlagenschalter positiv", group: "dryve" },
    { id: 6, label: "DI9 - Endlagenschalter negativ", group: "dryve" },
    { id: 7, label: "DI10 - Stopp/Reset", group: "dryve" },
    // Schrauber Outputs (8-12)
    { id: 8, label: "Programm Auswahl 1", group: "schrauber" },
    { id: 9, label: "Programm Auswahl 2", group: "schrauber" },
    { id: 10, label: "STOPMOTOR", group: "schrauber" },
    { id: 11, label: "START", group: "schrauber" },
    { id: 12, label: "IN ANG", group: "schrauber" },
    { id: 13, label: "IN RST", group: "schrauber" },
    // Druckluft Outputs (14-15)
    { id: 14, label: "Greifer", group: "druckluft" },
    { id: 15, label: "Magnetheber an", group: "druckluft" },
];

// Inputs-Daten
const inputsData = [
    // Dryve D1 Inputs (0-2)
    { id: 0, label: "DI1 - Referenzfahrt", group: "dryve" },
    { id: 1, label: "DI4 - Tippen links", group: "dryve" },
    { id: 2, label: "DI5 - Tippen rechts", group: "dryve" },
    // Schrauber Inputs (3-5)
    { id: 3, label: "37 - STOP", group: "schrauber" },
    { id: 4, label: "39 - END PR", group: "schrauber" },
    { id: 5, label: "42 - MOTOR ON", group: "schrauber" },
    // Druckluft Inputs (6-10)
    { id: 6, label: "Greifer Endschalter positiv", group: "druckluft" },
    { id: 7, label: "Greifer Endschalter negativ", group: "druckluft" },
    { id: 8, label: "Magnetheber Endschalter positiv", group: "druckluft" },
    { id: 9, label: "Magnetheber Endschalter negativ", group: "druckluft" },
    { id: 10, label: "Näherungsschalter Greifer", group: "druckluft" },
    // Unbeschriftete Inputs (11-15)
    { id: 11, label: "-", group: "none" },
    { id: 12, label: "-", group: "none" },
    { id: 13, label: "-", group: "none" },
    { id: 14, label: "-", group: "none" },
    { id: 15, label: "-", group: "none" }
];

const PinLayout = () => {
    const [inputs, setInputs] = useState(Array(16).fill(false));
    const [outputs, setOutputs] = useState(Array(16).fill(false));

    // WebSocket für Echtzeit-Updates der Inputs
    useEffect(() => {
        const ws = new WebSocket('ws://localhost:3000');
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'inputStatus') {
                setInputs(data.states);
            }
        };
        return () => ws.close();
    }, []);

    // Funktion zum Umschalten der Outputs
    const toggleOutput = async (index) => {
        const newState = !outputs[index];
        const newOutputs = [...outputs];
        newOutputs[index] = newState;
        setOutputs(newOutputs);

        try {
            await axios.post('/api/motor/set-output', { pin: index, state: newState });
        } catch (error) {
            console.error('Fehler beim Setzen des Outputs:', error);
        }
    };

    // Funktion zum Umschalten aller Outputs (für Testzwecke)
    const toggleAllOutputs = () => {
        setOutputs(outputs.map(state => !state));
    };

    // Stil für Statusanzeige (grün = An, rot = Aus)
    const getIndicatorStyle = (state) => ({
        width: '20px',
        height: '20px',
        borderRadius: '50%',
        backgroundColor: state ? 'green' : 'red',
        display: 'inline-block',
        marginRight: '10px'
    });

    // Farbkodierung nach Gruppe
    const getRowStyle = (group) => {
        switch (group) {
            case "dryve":
                return { backgroundColor: '#cce5ff' }; // Hellblau für Dryve D1
            case "schrauber":
                return { backgroundColor: '#ccffcc' }; // Hellgrün für Schrauber
            case "druckluft":
                return { backgroundColor: '#ffe6cc' }; // Hellorange für Druckluft
            default:
                return { backgroundColor: '#ffffff' }; // Weiß für unbeschriftet
        }
    };

    // Flexbox-Styling für nebeneinanderliegende Tabellen
    const containerStyle = {
        display: 'flex',
        justifyContent: 'space-between',
        gap: '20px',
        marginTop: '20px'
    };

    const tableWrapperStyle = {
        flex: '1',
        minWidth: '0' // Verhindert Überlauf
    };

    return (
        <div>
            <h2>Pin-Layout</h2>
            <div style={containerStyle}>

                {/* Outputs Tabelle */}
                <div style={tableWrapperStyle}>
                    <h3>Ausgänge (Outputs)</h3>
                    <table border="1" cellPadding="5" style={{ width: '100%' }}>
                        <thead>
                            <tr>
                                <th>Pin Nr.</th>
                                <th>Funktion</th>
                                <th>Status</th>
                                <th>Toggle</th>
                            </tr>
                        </thead>
                        <tbody>
                            {outputsData.map((output) => (
                                <tr key={output.id} style={getRowStyle(output.group)}>
                                    <td>{output.id}</td>
                                    <td>{output.label}</td>
                                    <td>
                                        <span style={getIndicatorStyle(outputs[output.id])}></span>
                                        {outputs[output.id] ? 'An' : 'Aus'}
                                    </td>
                                    <td>
                                        <button onClick={() => toggleOutput(output.id)}>Toggle</button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>

                {/* Inputs Tabelle */}
                <div style={tableWrapperStyle}>
                    <h3>Eingänge (Inputs)</h3>
                    <table border="1" cellPadding="5" style={{ width: '100%' }}>
                        <thead>
                            <tr>
                                <th>Pin Nr.</th>
                                <th>Funktion</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            {inputsData.map((input) => (
                                <tr key={input.id} style={getRowStyle(input.group)}>
                                    <td>{input.id}</td>
                                    <td>{input.label}</td>
                                    <td>
                                        <span style={getIndicatorStyle(inputs[input.id])}></span>
                                        {inputs[input.id] ? 'An' : 'Aus'}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>

            {/* Test-Button zum Umschalten aller Outputs */}
            <button onClick={toggleAllOutputs} style={{ marginTop: '20px', padding: '10px 20px' }}>
                Test: Alle Outputs umschalten
            </button>
        </div>
    );
};

export default PinLayout;

- StatusDisplay.js
  Inhalt:
import React from 'react';
import axios from 'axios';

const EmergencyStop = () => {
  const handleEmergencyStop = async () => {
    try {
      const response = await axios.post('/api/motor/emergency-stop');
      console.log(response.data);
    } catch (error) {
      console.error('Fehler beim Not-Aus', error);
    }
  };

  return (
    <div>
      <h2>Not-Aus</h2>
      <button style={{ backgroundColor: 'red', color: 'white' }} onClick={handleEmergencyStop}>
        Not-Aus
      </button>
    </div>
  );
};

export default EmergencyStop;


- MotorControl.js
  Inhalt:
import React, { useState } from 'react';
import axios from 'axios';

const MotorControl = () => {
  const [profile, setProfile] = useState('');

  const startProfile = async (profileName) => {
    try {
      const response = await axios.post('/api/motor/start-profile', { profileName });
      console.log(response.data);
      // TODO: Hier deditec API integrieren, um den Controller anzusprechen.
    } catch (error) {
      console.error('Fehler beim Starten des Profils', error);
    }
  };

  const handleButtonClick = (profileName) => {
    setProfile(profileName);
    startProfile(profileName);
  };

  return (
    <div>
      <h2>Fahrprofile</h2>
      <button onClick={() => handleButtonClick('Profile1')}>Fahrprofil 1</button>
      <button onClick={() => handleButtonClick('Profile2')}>Fahrprofil 2</button>
    </div>
  );
};

export default MotorControl;



[backend]
- server.js
  Inhalt:
const express = require('express');
const bodyParser = require('body-parser');
const motorRoutes = require('./routes/motor');
const WebSocket = require('ws');
const http = require('http');

const app = express();
app.use(bodyParser.json());
app.use('/api/motor', motorRoutes);

// HTTP-Server erstellen
const server = http.createServer(app);

// WebSocket-Server für Echtzeit-Updates
const wss = new WebSocket.Server({ server });
wss.on('connection', ws => {
  console.log('Client via WebSocket verbunden');
  ws.on('message', message => {
    console.log(`Nachricht erhalten: ${message}`);
    // Weitere Verarbeitung falls erforderlich
  });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server läuft auf Port ${PORT}`);
});


- package.json
  Inhalt:
{
  "name": "motor-control-backend",
  "version": "1.0.0",
  "description": "Backend for dryve 16 D1 motor control",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.13.0",
    "body-parser": "^1.20.1"
  }
}



[backend/config]
- drivingProfiles.json
  Inhalt:
{
    "Profile1": {
      "speed": 100,
      "acceleration": 50,
      "positions": [0, 100, 200]
    },
    "Profile2": {
      "speed": 80,
      "acceleration": 40,
      "positions": [0, 80, 160]
    }
  }
  


[backend/utils]
- logger.js
  Inhalt:
const logger = {
    info: msg => console.log(`INFO: ${msg}`),
    error: msg => console.error(`ERROR: ${msg}`),
    warn: msg => console.warn(`WARN: ${msg}`)
  };
  
  module.exports = logger;
  


[backend/routes]
- motor.js
  Inhalt:
const express = require('express');
const router = express.Router();
const drivingProfiles = require('../config/drivingProfiles.json');
const logger = require('../utils/logger');

// Starten eines Fahrprofils
router.post('/start-profile', (req, res) => {
  const { profileName } = req.body;
  const profile = drivingProfiles[profileName];
  if (!profile) {
    logger.error(`Fahrprofil ${profileName} nicht gefunden`);
    return res.status(404).json({ error: 'Fahrprofil nicht gefunden' });
  }
  logger.info(`Fahrprofil ${profileName} wird gestartet`);
  // Logik zur Motorsteuerung (z.B. über deditec API) implementieren
  res.json({ status: 'Fahrprofil gestartet', profile });
});

// Manuelle Steuerung
router.post('/manual-control', (req, res) => {
  const { command } = req.body;
  logger.info(`Manuelle Steuerung: ${command}`);
  res.json({ status: 'Befehl ausgeführt', command });
});

// Not-Aus
router.post('/emergency-stop', (req, res) => {
  logger.warn('Not-Aus aktiviert');
  res.json({ status: 'Not-Aus aktiviert' });
});

module.exports = router;



[java_jni_digital_input]

[java_jni_digital_input/bin]
- java_jni_usb_optoin_16_relais_16_digital_input_sample.class
  Inhalt:
   4 !  5java_jni_usb_optoin_16_relais_16_digital_input_sample  java/lang/Object console Ljava/io/BufferedReader; <init> ()V Code  java/lang/Error 
Unresolved compilation problems: 
	The declared package "java_jni_digital_input.src" does not match the expected package ""
	The method DapiSpecialCommand(int, int, int, int, int) in the type DelibJNI is not applicable for the arguments (long, int, int, int, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet8(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet8(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet32(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGetFF32(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiCloseModule(int) in the type DelibJNI is not applicable for the arguments (long)

 
    (Ljava/lang/String;)V LineNumberTable LocalVariableTable this 7Ljava_jni_usb_optoin_16_relais_16_digital_input_sample; IsError 
Exceptions  java/lang/Exception  !Unresolved compilation problem: 
 main ([Ljava/lang/String;)V CUnresolved compilation problems: 
	The method DapiSpecialCommand(int, int, int, int, int) in the type DelibJNI is not applicable for the arguments (long, int, int, int, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet1(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet8(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet8(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGet32(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiDIGetFF32(int, int) in the type DelibJNI is not applicable for the arguments (long, int)
	The method DapiCloseModule(int) in the type DelibJNI is not applicable for the arguments (long)
 
SourceFile :java_jni_usb_optoin_16_relais_16_digital_input_sample.java !      	          	   4     
 
Y                    
     	          	   *      
 
Y            #       	          	   *     
 
Y            Z             


[java_jni_digital_input/bin/DelibJava]
- DelibJNI.class
  Inhalt:
   4  DelibJava/DelibJNI  java/lang/Object USB_Interface8 I 
ConstantValue    
USB_CAN_STICK    USB_LOGI_500    
USB_SER_DEBUG    RO_SER    USB_BITP_200    RO_USB1    RO_USB RO_ETH    USB_MINI_STICK   	 USB_LOGI_18   
 RO_CAN    USB_SPI_MON    USB_WATCHDOG   
 USB_OPTOIN_8    USB_RELAIS_8 USB_OPTOIN_8_RELAIS_8    USB_OPTOIN_16_RELAIS_16    
USB_OPTOIN_32 
USB_RELAIS_32 USB_OPTOIN_32_RELAIS_32    
USB_OPTOIN_64 
USB_RELAIS_64 BS_USB_8 	BS_USB_16 	BS_USB_32 
USB_TTL_32    
USB_TTL_64 
RO_ETH_INTERN    BS_SER    BS_CAN    BS_ETH    NET_ETH    RO_CAN2    RO_USB2    	RO_ETH_LC    ETH_RELAIS_8    ETH_OPTOIN_8 ETH_O4_R4_ADDA    ETHERNET_MODULE    
ETH_TTL_64    NET_USB2    
NET_ETH_LC     NET_USB1   ! NET_SER   " "DAPI_SPECIAL_CMD_GET_MODULE_CONFIG DAPI_SPECIAL_CMD_TIMEOUT DAPI_SPECIAL_CMD_DI DAPI_SPECIAL_CMD_SET_DIR_DX_1 DAPI_SPECIAL_CMD_SET_DIR_DX_8 #DAPI_SPECIAL_CMD_GET_MODULE_VERSION DAPI_SPECIAL_CMD_DA DAPI_SPECIAL_CMD_WATCHDOG DAPI_SPECIAL_CMD_COUNTER DAPI_SPECIAL_CMD_AD DAPI_SPECIAL_CMD_CNT48 DAPI_SPECIAL_CMD_SOFTWARE_FIFO DAPI_SPECIAL_CMD_MODULE_REBOOT DAPI_SPECIAL_CMD_MODULE_RESCAN ,DAPI_SPECIAL_CMD_RESTART_CHECK_MODULE_CONFIG DAPI_SPECIAL_CMD_PWM %DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI (DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_FF -DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DI_COUNTER %DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DO %DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DX %DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_AD %DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_DA 'DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_TEMP *DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_STEPPER (DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_CNT48 ,DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PULSE_GEN *DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_PWM_OUT 0DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_INTERFACE1 .DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_FEATURE1 +DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_HW_GROUP +DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_SW_CLASS ,DAPI_SPECIAL_GET_MODULE_CONFIG_PAR_MODULE_ID %DAPI_SPECIAL_GET_MODULE_PAR_VERSION_0     %DAPI_SPECIAL_GET_MODULE_PAR_VERSION_1 %DAPI_SPECIAL_GET_MODULE_PAR_VERSION_2 %DAPI_SPECIAL_GET_MODULE_PAR_VERSION_3 "DAPI_SPECIAL_TIMEOUT_SET_VALUE_SEC DAPI_SPECIAL_TIMEOUT_ACTIVATE DAPI_SPECIAL_TIMEOUT_DEACTIVATE DAPI_SPECIAL_TIMEOUT_GET_STATUS #DAPI_SPECIAL_DI_FF_FILTER_VALUE_SET #DAPI_SPECIAL_DI_FF_FILTER_VALUE_GET  DAPI_SPECIAL_AD_READ_MULTIPLE_AD DAPI_SPECIAL_AD_FIFO_ACTIVATE DAPI_SPECIAL_AD_FIFO_DEACTIVATE DAPI_SPECIAL_AD_FIFO_GET_STATUS $DAPI_SPECIAL_AD_FIFO_SET_INTERVAL_MS  DAPI_SPECIAL_AD_FIFO_SET_CHANNEL DAPI_SPECIAL_AD_FIFO_INIT DAPI_SPECIAL_AD_FILTER_SET #DAPI_SPECIAL_DA_PAR_DA_LOAD_DEFAULT )DAPI_SPECIAL_DA_PAR_DA_SAVE_EEPROM_CONFIG )DAPI_SPECIAL_DA_PAR_DA_LOAD_EEPROM_CONFIG &DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_MSEC &DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_MSEC  DAPI_SPECIAL_WATCHDOG_GET_STATUS )DAPI_SPECIAL_WATCHDOG_GET_WD_COUNTER_MSEC 5DAPI_SPECIAL_WATCHDOG_GET_TIMEOUT_RELAIS_COUNTER_MSEC 3DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL1_COUNTER_MSEC 3DAPI_SPECIAL_WATCHDOG_SET_TIMEOUT_REL2_COUNTER_MSEC DAPI_SPECIAL_COUNTER_LATCH_ALL )DAPI_SPECIAL_COUNTER_LATCH_ALL_WITH_RESET DAPI_SPECIAL_CNT48_RESET_SINGLE DAPI_SPECIAL_CNT48_RESET_GROUP8 DAPI_SPECIAL_CNT48_LATCH_GROUP8 DAPI_SPECIAL_CNT48_DI_GET1 #DAPI_SPECIAL_SOFTWARE_FIFO_ACTIVATE %DAPI_SPECIAL_SOFTWARE_FIFO_DEACTIVATE %DAPI_SPECIAL_SOFTWARE_FIFO_GET_STATUS !DAPI_SPECIAL_PWM_FREQ_LOAD_DFAULT !DAPI_SPECIAL_PWM_FREQ_SAVE_EEPROM !DAPI_SPECIAL_PWM_FREQ_LOAD_EEPROM DAPI_SPECIAL_PWM_FREQ_SET DAPI_SPECIAL_AD_CH0_CH15 DAPI_SPECIAL_AD_CH16_CH31 DAPI_SPECIAL_AD_CH32_CH47 DAPI_SPECIAL_AD_CH48_CH63 %DAPI_SCANMODULE_GET_MODULES_AVAILABLE +DAPI_SW_CLASS_TYPE_OF_MODULE_IDENTIFICATION DAPI_SW_CLASS_DI_DO_DX_CHANNELS DAPI_SW_CLASS_AD_DA_CHANNELS DAPI_HW_GROUP_RO DAPI_HW_GROUP_LOGICANALYZER DAPI_HW_GROUP_DI_DO_AD_DA DAPI_HW_GROUP_USB DAPI_HW_GROUP_BS DAPI_HW_GROUP_NET DAPI_HW_GROUP_ETH   @ )DAPI_SW_FEATURE_BIT_SUPPORTED_BY_FIRMWARE !DAPI_SW_FEATURE_BIT_SOFTWARE_FIFO -DAPI_SW_FEATURE_BIT_CFG_DO_CMD_SET_CLR_BIT_32 DAPI_SW_FEATURE_BIT_EEPROM_RN23  DAPI_SW_FEATURE_BIT_EEPROM_E2_2K !DAPI_SW_FEATURE_BIT_EEPROM_E2_32K %DAPI_SW_FEATURE_BIT_EEPROM_FS_SUPPORT    DAPI_SW_FEATURE_BIT_DX_1_MODE ,DAPI_SW_FEATURE_BIT_AUTO_OUTPUTS_OFF_TIMEOUT    ,DAPI_SW_FEATURE_BIT_SUPP_INDIVIDUAL_CH_NAMES    'DAPI_SW_FEATURE_BIT_DEV_IO_REG_ERR_SUPP     $DAPI_SW_FEATURE_BIT_SUPP_SYSTEM_INFO  @   DAPI_SW_FEATURE_BIT_CFG_WATCHDOG    DAPI_SW_FEATURE_BIT_CFG_DI     DAPI_SW_FEATURE_BIT_CFG_DI_CNT@    $DAPI_SW_FEATURE_BIT_CFG_DI_CNT_LATCH    DAPI_SW_FEATURE_BIT_CFG_DI_FF    DAPI_SW_FEATURE_BIT_CFG_DO    %DAPI_SW_FEATURE_BIT_CFG_DO_WITH_TIMER    DAPI_SW_FEATURE_BIT_CFG_PWM_OUT    DAPI_SW_FEATURE_BIT_CFG_DX    DAPI_SW_FEATURE_BIT_CFG_DA    DAPI_SW_FEATURE_BIT_CFG_AD     !DAPI_SW_FEATURE_BIT_CFG_CNT_OUT32 @    DAPI_SW_FEATURE_BIT_CFG_CNT_IN48    DAPI_SW_FEATURE_BIT_CFG_TEMP    DAPI_SW_FEATURE_BIT_CFG_STEPPER    +DAPI_HW_INTERFACE_BIT_SUPPORTED_BY_FIRMWARE DAPI_HW_INTERFACE_BIT_CFG_ETH DAPI_HW_INTERFACE_BIT_CFG_CAN DAPI_HW_INTERFACE_BIT_CFG_RS232 %DAPI_HW_INTERFACE_BIT_CFG_RS232_RS485 DAPI_HW_INTERFACE_BIT_CFG_USB1 DAPI_HW_INTERFACE_BIT_CFG_USB2 !DAPI_HW_INTERFACE_PRODUCT_ID_MASK    DAPI_HW_INTERFACE_PRODUCT_ID_RO  DAPI_HW_INTERFACE_PRODUCT_ID_RO2 DAPI_HW_INTERFACE_PRODUCT_ID_BS     DAPI_HW_INTERFACE_PRODUCT_ID_NET #DAPI_HW_INTERFACE_PRODUCT_ID_NET_IP    *DAPI_TCP_FEATURE_BIT_SUPPORTED_BY_FIRMWARE DAPI_TCP_FEATURE_BIT_SUPP_RTC DAPI_CNT_MODE_READ DAPI_CNT_MODE_READ_WITH_RESET DAPI_CNT_MODE_READ_LATCHED DAPI_ADDA_MODE_UNIPOL_10V DAPI_ADDA_MODE_UNIPOL_5V DAPI_ADDA_MODE_UNIPOL_2V5 DAPI_ADDA_MODE_BIPOL_10V DAPI_ADDA_MODE_BIPOL_5V   A DAPI_ADDA_MODE_BIPOL_2V5   B DAPI_ADDA_MODE_0_20mA DAPI_ADDA_MODE_4_20mA    DAPI_ADDA_MODE_0_24mA    DAPI_ADDA_MODE_0_50mA    DAPI_ADDA_MODE_BI_CAL_MODE    DAPI_ADDA_MODE_0_20mA_TESTMODE    !DAPI_ADDA_MODE_BIPOL_10V_TESTMODE    DAPI_ADDA_MODE_DA_DISABLE    DAPI_ADDA_MODE_DA_ENABLE    &DAPI_ADDA_MODE_PREVENT_DAPI_MODE_ERROR    DAPI_ADDA_UNIT_ILLEGAL DAPI_ADDA_UNIT_VOLT DAPI_ADDA_UNIT_MA DAPI_STEPPER_ERR_NONE DAPI_STEPPER_ERR_PARAMETER DAPI_STEPPER_ERR_MOTOR_MOVE DAPI_STEPPER_ERR_DISABLE_MOVE !DAPI_STEPPER_ERR_DEVICE_NOT_FOUND DAPI_STEPPER_RETURN_0_BYTES DAPI_STEPPER_RETURN_1_BYTES DAPI_STEPPER_RETURN_2_BYTES DAPI_STEPPER_RETURN_4_BYTES    (DAPI_STEPPER_CMD_SET_MOTORCHARACTERISTIC (DAPI_STEPPER_CMD_GET_MOTORCHARACTERISTIC   DAPI_STEPPER_CMD_SET_POSITION DAPI_STEPPER_CMD_GO_POSITION DAPI_STEPPER_CMD_GET_POSITION   DAPI_STEPPER_CMD_SET_FREQUENCY 'DAPI_STEPPER_CMD_SET_FREQUENCY_DIRECTLY DAPI_STEPPER_CMD_GET_FREQUENCY   DAPI_STEPPER_CMD_FULLSTOP DAPI_STEPPER_CMD_STOP DAPI_STEPPER_CMD_GO_REFSWITCH DAPI_STEPPER_CMD_DISABLE 1DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_LOAD_DEFAULT 0DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_SAVE 0DAPI_STEPPER_CMD_MOTORCHARACTERISTIC_EEPROM_LOAD DAPI_STEPPER_CMD_GET_CPU_TEMP@   )DAPI_STEPPER_CMD_GET_MOTOR_SUPPLY_VOLTAGE   %DAPI_STEPPER_CMD_GO_POSITION_RELATIVE DAPI_STEPPER_CMD_EEPROM_ERASE DAPI_STEPPER_CMD_SET_VECTORMODE #DAPI_STEPPER_MOTORCHAR_PAR_STEPMODE &DAPI_STEPPER_MOTORCHAR_PAR_GOFREQUENCY )DAPI_STEPPER_MOTORCHAR_PAR_STARTFREQUENCY (DAPI_STEPPER_MOTORCHAR_PAR_STOPFREQUENCY 'DAPI_STEPPER_MOTORCHAR_PAR_MAXFREQUENCY ,DAPI_STEPPER_MOTORCHAR_PAR_ACCELERATIONSLOPE ,DAPI_STEPPER_MOTORCHAR_PAR_DECELERATIONSLOPE 'DAPI_STEPPER_MOTORCHAR_PAR_PHASECURRENT +DAPI_STEPPER_MOTORCHAR_PAR_HOLDPHASECURRENT #DAPI_STEPPER_MOTORCHAR_PAR_HOLDTIME (DAPI_STEPPER_MOTORCHAR_PAR_STATUSLEDMODE (DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW1 (DAPI_STEPPER_MOTORCHAR_PAR_INVERT_ENDSW2 (DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW1 (DAPI_STEPPER_MOTORCHAR_PAR_INVERT_REFSW2 +DAPI_STEPPER_MOTORCHAR_PAR_INVERT_DIRECTION -DAPI_STEPPER_MOTORCHAR_PAR_ENDSWITCH_STOPMODE ;DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOENDSWITCH >DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_AFTERENDSWITCH 8DAPI_STEPPER_MOTORCHAR_PAR_GOREFERENCEFREQUENCY_TOOFFSET "DAPI_STEPPER_GO_REFSWITCH_PAR_REF1 "DAPI_STEPPER_GO_REFSWITCH_PAR_REF2 &DAPI_STEPPER_GO_REFSWITCH_PAR_REF_LEFT 'DAPI_STEPPER_GO_REFSWITCH_PAR_REF_RIGHT -DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_POSITIVE -DAPI_STEPPER_GO_REFSWITCH_PAR_REF_GO_NEGATIVE 'DAPI_STEPPER_GO_REFSWITCH_PAR_SET_POS_0  DAPI_STEPPER_STATUS_GET_POSITION DAPI_STEPPER_STATUS_GET_SWITCH  DAPI_STEPPER_STATUS_GET_ACTIVITY DAPI_CAN_CMD_SET_BITRATE DAPI_CAN_CMD_SET_MASK0 DAPI_CAN_CMD_SET_RX_ADDRESS DAPI_CAN_CMD_CLR_TIMESTAMP DAPI_CAN_CMD_GET_BITRATE DAPI_CAN_CMD_GET_TIMESTAMP DAPI_CAN_CMD_TEST_GEN_RX_PACK DAPI_PAR_CAN_MESSAGE_BOX_0 DAPI_PAR_CAN_MESSAGE_BOX_1 DAPI_PAR_CAN_MESSAGE_BOX_2 DAPI_PAR_CAN_MESSAGE_BOX_3 DAPI_CAN_BITRATE_10000  ' DAPI_CAN_BITRATE_20000  N  DAPI_CAN_BITRATE_50000  P DAPI_CAN_BITRATE_100000  DAPI_CAN_BITRATE_125000 H DAPI_CAN_BITRATE_250000 А DAPI_CAN_BITRATE_500000   DAPI_CAN_BITRATE_1000000 B@ DAPI_CAN_MASK_SINGLE DAPI_CAN_MASK_ALL DAPI_CNT48_FILTER_20ns DAPI_CNT48_FILTER_100ns DAPI_CNT48_FILTER_250ns DAPI_CNT48_FILTER_500ns  0  DAPI_CNT48_FILTER_1us DAPI_CNT48_FILTER_2_5us  P  DAPI_CNT48_FILTER_5us  `  DAPI_CNT48_FILTER_10us  p  DAPI_CNT48_FILTER_25us DAPI_CNT48_FILTER_50us    DAPI_CNT48_FILTER_100us    DAPI_CNT48_FILTER_250us    DAPI_CNT48_FILTER_500us    DAPI_CNT48_FILTER_1ms    DAPI_CNT48_FILTER_2_5ms    DAPI_CNT48_FILTER_5ms    !DAPI_CNT48_MODE_COUNT_RISING_EDGE $DAPI_CNT48_MODE_COUNT_RISING_EDGE_X2 $DAPI_CNT48_MODE_COUNT_RISING_EDGE_X4 DAPI_CNT48_MODE_T DAPI_CNT48_MODE_FREQUENCY DAPI_CNT48_MODE_PWM DAPI_CNT48_SUBMODE_NO_RESET "DAPI_CNT48_SUBMODE_RESET_WITH_READ 'DAPI_CNT48_SUBMODE_NO_RESET_NO_HW_RESET .DAPI_CNT48_SUBMODE_RESET_WITH_READ_NO_HW_RESET   0  DAPI_CNT48_SUBMODE_RESET_ON_CH_7   p DAPI_CNT48_SUBMODE_LATCH_COMMON *DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_1ms +DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_10ms ,DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_100ms +DAPI_CNT48_SUBMODE_FREQUENCY_TIME_BASE_1sec DAPI_FIFO_TYPE_READ_AD_FIFO DAPI_PWM_FREQUENCY_10HZ DAPI_PWM_FREQUENCY_100HZ DAPI_PWM_FREQUENCY_250HZ DAPI_PWM_FREQUENCY_1000HZ   d $DAPI_OPEN_MODULE_OPTION_USE_EXBUFFER !DAPI_OPEN_MODULE_OPTION_NO_RESCAN %DAPI_OPEN_MODULE_ENCRYPTION_TYPE_NONE 'DAPI_OPEN_MODULE_ENCRYPTION_TYPE_NORMAL &DAPI_OPEN_MODULE_ENCRYPTION_TYPE_ADMIN +DAPI_OPEN_MODULE_ENCRYPTION_TYPE_ADMIN_TEMP <init> ()V Code java/lang/Error Unresolved compilation problem: 
	The declared package "java_jni_digital_input.src.DelibJava" does not match the expected package "DelibJava"

 (Ljava/lang/String;)V LineNumberTable LocalVariableTable this LDelibJava/DelibJNI; DapiOpenModule (II)I !Unresolved compilation problem: 
 DapiCloseModule (I)I DapiScanModule DapiScanAllModulesAvailable &DapiScanAllModulesAvailableListEcecute DapiGetDELIBVersion DapiPing 
DapiWriteByte (III)V 
DapiWriteWord 
DapiWriteLong DapiWriteLongLong (IIJ)V DapiReadByte DapiReadWord DapiReadLong DapiReadLongLong (II)J DapiGetLastError ()I DapiClearLastError 
DapiDIGet1 
DapiDIGet8 DapiDIGet16 DapiDIGet32 DapiDIGet64 
DapiDIGetFF32 DapiDIGetCounter (III)I 
DapiDOSet1 
DapiDOSet8 DapiDOSet16 DapiDOSet32 DapiDOSet64 DapiDOReadback32 DapiDOReadback64 DapiDOSet1_WithTimer (IIII)V DapiDOSetBit32 DapiDOClrBit32 	DapiADGet 
DapiADGetVolt (II)F DapiADGetmA 
DapiADSetMode 
DapiADGetMode 	DapiDASet 
DapiDASetVolt (IIF)V DapiDASetmA 
DapiDASetMode 
DapiDAGetMode DapiTempGet DapiCnt48ModeSet DapiCnt48ModeGet DapiCnt48CounterGet32 DapiCnt48CounterGet48 DapiPulseGenSet 	(IIIIII)V 
DapiPWMOutSet DapiStepperCommand 
(IIIIIII)I DapiStepperCommandEx 
(IIIIIIIIII)I DapiStepperGetStatus DapiWatchdogEnable (I)V DapiWatchdogDisable DapiWatchdogRetrigger DapiSpecialCommand (IIIII)I 
SourceFile 
DelibJNI.java !    A           	       
           
                                                                                                  !  "       #  $       #  %       &  '       (  )       (  *       (  +       ,  -       ,  .       ,  /       &  0       (  1       ,  2       3  4       3  5       6  7       8  9       :  ;       <  =       >  ?       @  A       B  C       D  E       F  G       F  H       I  J       K  L       M  N       O  P       Q  R       S  T       U  V         W       
  X         Y         Z         [         \         ]         ^         _         `         a         b       !  c       #  d       &  e       6  f         g         h         i       
  j         k         l         m         n         o         p         q         r       !  s       #  t       &  u       (  v       ,  w       x  y         z       
  {         |         }       
  ~                                  
                  
                                                                        
                           
                                                               
                  
                                    
                           
                           x                  
                                    
                           
                           (         Q                           
                           Q                           (                                                                                                                                                                                             
                           (         Q                                                                                 
         x                  
         x                  
                                                                                 	 
             
               x                
        x                
                       x                                        !        "        #      $ %        &        '      ( )        *       ( +       , ,       8 -       : .       < /       > 0      1 2      3 4       Q 5       S 6        7        8       
 9        :        ;        <        =        >        ?        @        A        B        C       ! D       # E       & F       ( G       , H       3 I       6 J       8 K        L       
 M        N        O       ( P       Q Q        R        S       
 T        U        V       
 W        X        Y        Z        [      \ ]       x ^        _       
 `        a      b c      d e      f g      h i      j k      l m      n o      p q       r       x s       x t        u        v      w x        y      z {      | }      ~                                                                x                
        !        #        &        x        (        Q                                     Q        (        x                                B                       
        x                
         ;     5     Y                    	    +     Y               	    +     Y               	    +     Y               	    +     Y               	    +     Y               	    +     Y         !      	    +     Y         #      	    +     Y         '      	    +     Y         (      	    +     Y         )      	    +     Y         *      	    +     Y         ,      	    +     Y         -      	    +     Y         .      	    +     Y         /      	    +      Y         3      	    +      Y         5      	    +     Y         9      	    +     Y         :      	    +     Y         ;      	    +     Y         <      	    +     Y         =      	    +     Y         ?      	    +     Y         A      	    +     Y         E      	    +     Y         F      	    +     Y         G      	    +     Y         H      	    +     Y         I      	    +     Y         K      	    +     Y         L      	    +     Y         N      	    +     Y         O      	    +     Y         P      	    +     Y         T      	    +     Y         V      	    +     Y         W      	    +     Y         X      	    +     Y         Y      	    +     Y         ]      	    +     Y         ^      	    +     Y         _      	    +     Y         a      	    +     Y         b      	    +     Y         f      	    +     Y         j      	    +     Y         k      	    +     Y         l      	    +     Y         m      	    +     Y         q      	    +     Y         u      	    +     Y         y      	    +  
   Y         z      	    +     Y         {      	     +     Y               	     +     Y               	     +     Y               	    +     Y                  

- DelibErrorCodes.class
  Inhalt:
   4   DelibJava/DelibErrorCodes  java/lang/Object 
DAPI_ERR_NONE I 
ConstantValue     DAPI_ERR_GEN_CLASS    DAPI_ERR_GEN_MALLOC_ERROR   #DAPI_ERR_GEN_BUFFER_TOO_SMALL_ERROR   DAPI_ERR_GEN_ERROR_WITH_TEXT   DAPI_ERR_GEN_SOCKET_ERROR   DAPI_ERR_GEN_BINDING_ERROR   DAPI_ERR_GEN_SIG_HANDLER_ERROR   $DAPI_ERR_GEN_UNKNOWN_ENCRYPTION_TYPE    DAPI_ERR_GEN_ENCRYPTION_ERROR  ! DAPI_ERR_GEN_ILLEGAL_MODULE_ID  0 DAPI_ERR_GEN_ILLEGAL_MODULE_NR  1 DAPI_ERR_GEN_ILLEGAL_HANDLE  2 DAPI_ERR_GEN_NOT_SUPPORTED_MODE  @ "DAPI_ERR_GEN_NOT_SUPPORTED_IO_TYPE  A "DAPI_ERR_GEN_NOT_SUPPORTED_CHANNEL  B %DAPI_ERR_GEN_NOT_SUPPORTED_SW_FEATURE  C #DAPI_ERR_GEN_NOT_SUPPORTED_FUNCTION  D DAPI_ERR_COM_CLASS    *DAPI_ERR_COM_CONN_COULD_NOT_BE_ESTABLISHED   "DAPI_ERR_COM_DEVICE_DID_NOT_ANSWER   DAPI_ERR_COM_HANDLE_INVALID   DAPI_ERR_COM_DELIB_ID_INVALID   DAPI_ERR_COM_FT_HANDLE_INVALID   DAPI_ERR_COM_FT_ERROR   DAPI_ERR_DEV_CLASS    DAPI_ERR_DEV_PKT_CMD_ILLEGAL   "DAPI_ERR_DEV_PKT_DATA_LENGTH_ERROR   $DAPI_ERR_DEV_PKT_DATA_CHECKSUM_ERROR    DAPI_ERR_DEV_PKT_ADDR_NOT_FOR_ME   DAPI_ERR_DEV_PKT_OTHER_ERROR   %DAPI_ERR_DEV_PACKET_CMD_NOT_SUPPORTED   $DAPI_ERR_DEV_PACKET_ID_1_NOT_ALLOWED   &DAPI_ERR_DEV_PACKET_ID_1_NOT_SUPPORTED   !DAPI_ERR_DEV_PACKET_HEADER_NOT_OK   (DAPI_ERR_DEV_PACKET_SUBCMD_NOT_SUPPORTED   DAPI_ERR_DEV_IO_ADDR_ILLEGAL  1 DAPI_ERR_DEV_IO_RD_WR_ERROR  2  DAPI_ERR_DEV_IO_SUB_ADDR_ILLEGAL  3 DAPI_ERR_DEV_IO_OTHER_ERROR  7 "DAPI_ERR_DEV_IO_HTML_ACCESS_DENIED  8 .DAPI_ERR_DEV_FS_INTERNAL_TEXT_BUFFER_TOO_SMALL  E &DAPI_ERR_DEV_FS_RW_OFFSET_OUT_OF_SCOPE  F &DAPI_ERR_DEV_FS_RW_LENGTH_OUT_OF_SCOPE  G  DAPI_ERR_DEV_FS_BUFFER_TOO_SMALL  I DAPI_ERR_DEV_FILE_WRITE_ERROR  p #DAPI_ERR_DEV_CONFIG_WRITE_PROTECTED   #DAPI_ERR_DEV_CONFIG_KEY_NOT_PRESSED   DAPI_ERR_DEV_CONFIG_READ_ERROR   DAPI_ERR_DEV_CONFIG_WRITE_ERROR    DAPI_ERR_DEV_CONFIG_UPDATE_ERROR   1DAPI_ERR_DEV_CONFIG_PARAM_ONLY_ONE_TIME_WRITEABLE   &DAPI_ERR_DEV_CONFIG_PARAM_IS_READ_ONLY   'DAPI_ERR_DEV_CONFIG_PARAM_IS_WRITE_ONLY   &DAPI_ERR_DEV_CONFIG_WRITE_PROTECTED_SW   DAPI_ERR_DEV_CONFIG_FS_INVALID   $DAPI_ERR_DEV_CONFIG_FS_DIR_NOT_FOUND   (DAPI_ERR_DEV_CONFIG_FS_DIR_ALREADY_EXIST   DAPI_ERR_DEV_CONFIG_FS_IS_FULL   'DAPI_ERR_DEV_CONFIG_FS_DIR_DATA_INVALID   $DAPI_ERR_DEV_ENCRYPTED_HEADER_NOT_OK   DAPI_ERR_DEV_ENCRYPTION_ERROR   3DAPI_ERR_DEV_ENCRYPTION_TEMP_ADMIN_MODE_NOT_ALLOWED   'DAPI_ERR_DEV_ENCRYPTION_NO_ADMIN_RIGHTS   DAPI_ERR_DEV_EXECUTE_CMD_ERROR   <init> ()V Code  java/lang/Error  Unresolved compilation problem: 
	The declared package "java_jni_digital_input.src.DelibJava" does not match the expected package "DelibJava"

     (Ljava/lang/String;)V LineNumberTable LocalVariableTable this LDelibJava/DelibErrorCodes; 
SourceFile DelibErrorCodes.java !     A           	       
           
                                                                                           !       "  #       $  %       &  '       (  )       *  +       ,  -       .  /       0  1       2  3       4  5       6  7       8  9       :  ;       <  =       >  ?       @  A       B  C       D  E       F  G       H  I       J  K       L  M       N  O       P  Q       R  S       T  U       V  W       X  Y       Z  [       \  ]       ^  _       `  a       b  c       d  e       f  g       h  i       j  k       l  m       n  o       p  q       r  s       t  u       v  w       x  y       z  {       |  }       ~                                                      4     
 Y                    
          


